<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algocdk Trading Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#FF4500',
                        secondary: '#FF6347',
                        success: '#00C851',
                        danger: '#FF4444',
                        warning: '#FFBB33',
                        dark: '#0D1421',
                        darker: '#0A0E1A',
                        accent: '#1E293B'
                    }
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0D1421;
            color: #E2E8F0;
            overflow: hidden;
        }
        
        /* Mobile First - Complete Redesign */
        @media (max-width: 768px) {
            body {
                font-size: 14px !important;
                overflow-x: hidden !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            /* Mobile navigation */
            nav {
                padding: 8px 12px !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 1000 !important;
                background: #0A0E1A !important;
                border-bottom: 1px solid #374151 !important;
            }
            
            nav .flex {
                flex-wrap: nowrap !important;
                align-items: center !important;
            }
            
            nav .flex > div:first-child {
                flex: 1 !important;
            }
            
            nav .nav-ticker {
                display: none !important;
            }
            
            nav .flex > div:last-child {
                flex-shrink: 0 !important;
            }
            
            nav .text-right {
                display: none !important;
            }
            
            /* Mobile menu button */
            #navMenuBtn {
                padding: 8px 12px !important;
                font-size: 14px !important;
                min-height: 36px !important;
            }
            
            /* Mobile dropdown menu */
            #navMenu {
                position: fixed !important;
                top: 60px !important;
                right: 12px !important;
                left: 12px !important;
                width: auto !important;
                max-height: 70vh !important;
                overflow-y: auto !important;
                background: #0A0E1A !important;
                border: 1px solid #374151 !important;
                border-radius: 8px !important;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5) !important;
            }
            
            #navMenu a {
                padding: 16px 20px !important;
                font-size: 16px !important;
                border-bottom: 1px solid #374151 !important;
            }
            
            #navMenu a:last-child {
                border-bottom: none !important;
            }
            
            /* Mobile container */
            .flex.h-screen {
                flex-direction: column !important;
                height: 100vh !important;
                overflow: hidden !important;
                padding-top: 60px !important;
            }
            
            /* Hide market watch on mobile to save space */
            .w-80:first-child {
                display: none !important;
            }
            
            /* Chart takes top portion */
            .flex-1 {
                height: calc(60vh - 60px) !important;
                order: 1 !important;
                position: relative !important;
                min-height: 250px !important;
            }
            
            /* Trading panel takes bottom portion */
            .w-80:last-child {
                height: 40vh !important;
                width: 100% !important;
                order: 2 !important;
                overflow-y: auto !important;
                border-left: none !important;
                border-top: 2px solid #FF4500 !important;
                background: #0A0E1A !important;
                min-height: 200px !important;
            }
            
            /* Simplified mobile controls */
            #controls {
                position: absolute !important;
                top: 8px !important;
                left: 8px !important;
                right: 8px !important;
                background: rgba(13, 20, 33, 0.95) !important;
                padding: 8px !important;
                border-radius: 8px !important;
                display: flex !important;
                flex-wrap: wrap !important;
                gap: 6px !important;
                z-index: 100 !important;
                border: 1px solid #374151 !important;
                max-height: 80px !important;
                overflow: hidden !important;
            }
            
            #controls select, #controls button {
                padding: 6px 10px !important;
                font-size: 12px !important;
                min-height: 32px !important;
                border-radius: 6px !important;
                margin: 0 !important;
                flex: 1 !important;
                min-width: 80px !important;
                background: #1E293B !important;
                border: 1px solid #475569 !important;
                color: #E2E8F0 !important;
            }
            
            /* Hide complex controls on mobile */
            #drawingTool, #drawingColor, #lineStyle, #lineWidth, 
            #clearDrawings, #chartType, #alertBtn, #screenshotBtn,
            #indicators, #customIndicatorFile, #customIndicatorCode,
            #customIndicatorButtons, #fullscreenBtn {
                display: none !important;
            }
            
            /* Chart info panel mobile */
            .chart-info {
                top: 100px !important;
                right: 8px !important;
                font-size: 10px !important;
                padding: 6px !important;
            }
            
            /* Mobile Trading Panel */
            .w-80:last-child .p-4 {
                padding: 12px !important;
            }
            
            .w-80:last-child h3 {
                font-size: 16px !important;
                margin-bottom: 10px !important;
                color: #FF4500 !important;
                font-weight: 700 !important;
            }
            
            .w-80:last-child h4 {
                font-size: 14px !important;
                margin-bottom: 8px !important;
                color: #E2E8F0 !important;
            }
            
            .w-80:last-child .space-y-3 > * + * {
                margin-top: 10px !important;
            }
            
            .w-80:last-child input, 
            .w-80:last-child select {
                padding: 10px 12px !important;
                font-size: 14px !important;
                min-height: 44px !important;
                border-radius: 6px !important;
                background: #1E293B !important;
                border: 2px solid #475569 !important;
                color: #E2E8F0 !important;
            }
            
            .w-80:last-child input:focus,
            .w-80:last-child select:focus {
                border-color: #FF4500 !important;
                outline: none !important;
            }
            
            .w-80:last-child button {
                padding: 12px 16px !important;
                font-size: 14px !important;
                min-height: 48px !important;
                border-radius: 6px !important;
                font-weight: 700 !important;
                border: none !important;
                cursor: pointer !important;
                transition: all 0.2s ease !important;
            }
            
            .w-80:last-child button:active {
                transform: scale(0.98) !important;
            }
            
            /* Mobile grid adjustments */
            .grid-cols-2 {
                gap: 10px !important;
            }
            
            /* Mobile text sizes */
            .text-xs {
                font-size: 12px !important;
            }
            
            .text-sm {
                font-size: 14px !important;
            }
            
            /* Account toggle mobile */
            .w-11 {
                width: 44px !important;
            }
            .h-6 {
                height: 24px !important;
            }
            
            /* Mobile trade summary */
            .bg-accent.bg-opacity-50 {
                padding: 12px !important;
                margin-top: 12px !important;
                border-radius: 6px !important;
                background: rgba(30, 41, 59, 0.8) !important;
                border: 1px solid #475569 !important;
            }
            
            /* Mobile recent trades */
            .w-80:last-child .flex-1 {
                height: auto !important;
                max-height: 120px !important;
                overflow-y: auto !important;
            }
            
            /* Mobile positions */
            .w-80:last-child .border-b:last-of-type {
                border-bottom: none !important;
            }
            
            /* Mobile account status */
            #accountStatus {
                background: rgba(30, 41, 59, 0.6) !important;
                border: 1px solid #475569 !important;
                border-radius: 6px !important;
                padding: 10px !important;
            }
            
            /* Mobile notifications */
            .notification {
                top: 80px !important;
                right: 10px !important;
                left: 10px !important;
                transform: translateY(-100px) !important;
                font-size: 13px !important;
            }
            
            .notification.show {
                transform: translateY(0) !important;
            }
        }
        
        /* Tablet adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            .w-80:first-child {
                width: 250px !important;
            }
            
            .w-80:last-child {
                width: 280px !important;
            }
            
            #controls {
                left: 260px !important;
                flex-wrap: wrap !important;
                max-width: calc(100% - 550px) !important;
            }
            
            #controls select, #controls button {
                font-size: 13px !important;
                padding: 6px 10px !important;
                min-width: 100px !important;
            }
        }
        
        /* Very small phones */
        @media (max-width: 400px) {
            .flex-1 {
                height: 55vh !important;
                min-height: 250px !important;
            }
            
            .w-80:last-child {
                height: 45vh !important;
                min-height: 200px !important;
            }
            
            #controls select, #controls button {
                font-size: 11px !important;
                min-height: 30px !important;
                min-width: 70px !important;
                padding: 5px 8px !important;
            }
            
            .w-80:last-child input, 
            .w-80:last-child select {
                padding: 8px 10px !important;
                font-size: 13px !important;
                min-height: 40px !important;
            }
            
            .w-80:last-child button {
                padding: 10px 14px !important;
                font-size: 13px !important;
                min-height: 44px !important;
            }
            
            nav {
                padding: 8px 12px !important;
            }
            
            nav .nav-ticker-content {
                font-size: 10px !important;
            }
        }
        
        /* Large screens optimization */
        @media (min-width: 1440px) {
            .w-80:first-child {
                width: 320px !important;
            }
            
            .w-80:last-child {
                width: 350px !important;
            }
            
            #controls {
                left: 330px !important;
                max-width: calc(100% - 680px) !important;
            }
        }
        
        #chart {
            background: #0e1117;
            display: block;
            cursor: grab;
        }
        
        #chart:active {
            cursor: grabbing;
        }
        
        #controls {
            position: fixed;
            top: 80px;
            left: 10px;
            background: #161b22;
            border: 1px solid #2b2f3a;
            border-radius: 6px;
            padding: 8px;
            display: flex;
            gap: 10px;
            z-index: 100;
            flex-wrap: wrap;
        }
        
        #controls select {
            background: #0e1117;
            color: #d1d4dc;
            border: 1px solid #2b2f3a;
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 120px;
        }
        
        #activeIndicators {
            position: fixed;
            top: 120px;
            left: 10px;
            z-index: 100;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            max-width: 300px;
        }
        
        .indicator-tag {
            background: #2b2f3a;
            color: #d1d4dc;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid #444;
        }
        
        .indicator-tag:hover {
            background: #ff4444;
        }
        
        .indicator-config {
            position: absolute;
            top: 30px;
            left: 0;
            background: #2b2f3a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            z-index: 200;
            min-width: 200px;
            display: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .config-input {
            width: 60px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #d1d4dc;
            padding: 4px;
            border-radius: 2px;
            margin: 2px;
        }
        
        .config-label {
            font-size: 11px;
            color: #d1d4dc;
            margin-right: 5px;
        }
        
        .config-button {
            background: #4a5568;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 2px;
            font-size: 11px;
            margin: 2px;
            cursor: pointer;
        }
        
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 20, 33, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #2b2f3a;
            border-top: 3px solid #FF4500;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        

        
        /* Price ticker in navigation */
        .nav-ticker {
            flex: 1;
            overflow: hidden;
            margin: 0 20px;
            position: relative;
        }
        
        .nav-ticker-content {
            display: flex;
            animation: navScroll 25s linear infinite;
            white-space: nowrap;
        }
        
        .nav-ticker-item {
            margin-right: 30px;
            display: flex;
            align-items: center;
            font-size: 12px;
        }
        
        .nav-ticker-symbol {
            font-weight: 600;
            margin-right: 6px;
            color: #FF4500;
        }
        
        .nav-ticker-price {
            font-family: 'Courier New', monospace;
            margin-right: 6px;
        }
        
        .nav-ticker-change {
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 2px;
        }
        
        .nav-ticker-up {
            background: rgba(0, 193, 118, 0.2);
            color: #00C851;
        }
        
        .nav-ticker-down {
            background: rgba(255, 68, 68, 0.2);
            color: #FF4444;
        }
        
        @keyframes navScroll {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }
        .connection-status {
            position: fixed;
            top: 30px;
            right: 10px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .status-connected {
            background: rgba(0, 193, 118, 0.2);
            color: #00C851;
            border: 1px solid #00C851;
        }
        
        .status-disconnected {
            background: rgba(255, 68, 68, 0.2);
            color: #FF4444;
            border: 1px solid #FF4444;
        }
        
        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Professional Chart Enhancements */
        .chart-info {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(13, 20, 33, 0.9);
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 8px;
            font-size: 11px;
            color: #E2E8F0;
            backdrop-filter: blur(10px);
            z-index: 99;
        }
        
        .chart-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
            min-width: 120px;
        }
        
        .chart-info-label {
            color: #9CA3AF;
        }
        
        .chart-info-value {
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }
        
        /* Success/Error Notifications */
        .notification {
            position: fixed;
            top: 60px;
            right: 20px;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 1002;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification-success {
            background: linear-gradient(135deg, #00C851, #00A843);
            color: white;
            border-left: 4px solid #00FF00;
        }
        
        .notification-error {
            background: linear-gradient(135deg, #FF4444, #CC3333);
            color: white;
            border-left: 4px solid #FF0000;
        }
        
        .notification-info {
            background: linear-gradient(135deg, #FF4500, #E63900);
            color: white;
            border-left: 4px solid #FFA500;
        }
        
        .alert-panel {
            position: fixed;
            top: 200px;
            right: 10px;
            background: #2b2f3a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            width: 250px;
            z-index: 200;
            display: none;
        }
        
        .alert-item {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .alert-triggered {
            background: #ff4444 !important;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .trading-panel {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(71, 85, 105, 0.4);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .market-item {
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .market-item:hover {
            background: rgba(255, 69, 0, 0.1);
            border-left-color: #FF4500;
        }
        
        .market-item.selected {
            background: rgba(255, 69, 0, 0.15);
            border-left-color: #FF4500;
        }
        
        .price-up { color: #00C851; }
        .price-down { color: #FF4444; }
    </style>
</head>
<body class="bg-dark text-gray-100">

    
    <!-- Connection Status -->
    <div class="connection-status status-connected" id="connectionStatus">
        <div class="status-dot"></div>
        <span>Connected</span>
    </div>
    
    <!-- Notification Container -->
    <div id="notificationContainer"></div>
    <!-- Top Navigation -->
    <nav class="bg-darker border-b border-gray-700 px-6 py-3 relative z-20">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-6">
                <div class="flex items-center space-x-2">
                    <div class="w-8 h-8 bg-gradient-to-r from-primary to-secondary rounded-lg flex items-center justify-center">
                        <i class="fas fa-chart-line text-white text-sm"></i>
                    </div>
                    <span class="text-xl font-bold">Algocdk</span>
                </div>
                
                <!-- Price Ticker -->
                <div class="nav-ticker">
                    <div class="nav-ticker-content" id="navPriceTicker">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="flex items-center space-x-4">
                <div class="text-right">
                    <div class="text-sm text-gray-400">Balance</div>
                    <div class="font-mono font-bold" id="topAccountBalance">$10,000.00</div>
                </div>
                
                <!-- Navigation Menu -->
                <div class="relative">
                    <button id="navMenuBtn" class="flex items-center space-x-2 bg-accent hover:bg-gray-600 px-3 py-2 rounded transition-colors">
                        <i class="fas fa-bars"></i>
                        <span>Menu</span>
                    </button>
                    <div id="navMenu" class="absolute right-0 top-12 bg-darker border border-gray-600 rounded-lg shadow-lg w-48 z-50 hidden">
                        <a href="/profile" class="flex items-center space-x-2 px-4 py-3 hover:bg-accent transition-colors">
                            <i class="fas fa-user"></i>
                            <span>Profile</span>
                        </a>
                        <a href="/settings" class="flex items-center space-x-2 px-4 py-3 hover:bg-accent transition-colors">
                            <i class="fas fa-cog"></i>
                            <span>Settings</span>
                        </a>
                        <a href="/mybots" class="flex items-center space-x-2 px-4 py-3 hover:bg-accent transition-colors">
                            <i class="fas fa-robot"></i>
                            <span>My Bots</span>
                        </a>
                        <a href="/botstore" class="flex items-center space-x-2 px-4 py-3 hover:bg-accent transition-colors">
                            <i class="fas fa-store"></i>
                            <span>Bot Store</span>
                        </a>
                        <a href="/trading" class="flex items-center space-x-2 px-4 py-3 hover:bg-accent transition-colors">
                            <i class="fas fa-exchange-alt"></i>
                            <span>Advanced Trading</span>
                        </a>
                        <a href="/marketchart" class="flex items-center space-x-2 px-4 py-3 hover:bg-accent transition-colors">
                            <i class="fas fa-chart-area"></i>
                            <span>Market Chart</span>
                        </a>
                        <a href="/support" class="flex items-center space-x-2 px-4 py-3 hover:bg-accent transition-colors">
                            <i class="fas fa-life-ring"></i>
                            <span>Support</span>
                        </a>
                        <div class="border-t border-gray-600 my-1"></div>
                        <a href="#" onclick="exitApp()" class="flex items-center space-x-2 px-4 py-3 hover:bg-accent transition-colors text-red-400">
                            <i class="fas fa-sign-out-alt"></i>
                            <span>Exit App</span>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Interface -->
    <div class="flex h-screen">
        <!-- Left Panel - Market Watch -->
        <div class="w-80 bg-darker border-r border-gray-700 flex flex-col relative z-10">
            <div class="p-4 border-b border-gray-700">
                <h3 class="font-semibold mb-3 text-sm">Market Watch</h3>
                <div class="relative mb-3">
                    <input type="text" placeholder="Search markets..." 
                           class="w-full bg-accent border border-gray-600 rounded px-3 py-2 text-sm">
                    <i class="fas fa-search absolute right-3 top-2.5 text-gray-400 text-xs"></i>
                </div>
            </div>
            
            <div class="flex-1 overflow-y-auto">
                <div id="marketList" class="p-2">
                    <!-- Market items populated by JS -->
                </div>
            </div>
        </div>

        <!-- Center Panel - Chart -->
        <div class="flex-1 relative min-w-0">
            <!-- Chart Controls -->
            <div id="controls">
                <button id="fullscreenBtn" onclick="toggleFullscreen()" style="background: #4a5568; border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-right: 10px;" title="Toggle Fullscreen">
                    <i class="fas fa-expand"></i>
                </button>
                <select id="drawingTool" onchange="setDrawingTool(this.value)" style="background: #0e1117; color: #d1d4dc; border: 1px solid #2b2f3a; padding: 4px 8px; border-radius: 4px; min-width: 120px; margin-right: 10px;">
                    <option value="">Drawing Tools</option>
                    <option value="text">Text Label</option>
                    <option value="line">Trend Line</option>
                    <option value="ray">Ray</option>
                    <option value="horizontal">Horizontal Line</option>
                    <option value="vertical">Vertical Line</option>
                    <option value="arrow">Arrow</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="circle">Circle</option>
                    <option value="fibonacci">Fibonacci</option>
                    <option value="fibext">Fib Extension</option>
                    <option value="channel">Channel</option>
                    <option value="pitchfork">Pitchfork</option>
                    <option value="gann">Gann Fan</option>
                    <option value="delete">üóëÔ∏è Delete Mode</option>
                </select>
                <input type="color" id="drawingColor" value="#ffff00" style="width: 30px; height: 30px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;" title="Drawing Color">
                <select id="lineStyle" style="background: #0e1117; color: #d1d4dc; border: 1px solid #2b2f3a; padding: 4px 8px; border-radius: 4px; margin-right: 10px;">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                </select>
                <input type="range" id="lineWidth" min="1" max="5" value="2" style="margin-right: 10px;" title="Line Width">
                <button id="clearDrawings" onclick="clearAllDrawings()" style="background: #ff4444; border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-right: 10px;" title="Clear All Drawings">
                    <i class="fas fa-eraser"></i>
                </button>
                <select id="chartType" onchange="setChartType(this.value)" style="background: #0e1117; color: #d1d4dc; border: 1px solid #2b2f3a; padding: 4px 8px; border-radius: 4px; min-width: 100px; margin-right: 10px;">
                    <option value="candles">Candles</option>
                    <option value="line">Line</option>
                    <option value="area">Area</option>
                    <option value="bars">Bars</option>
                </select>
                <button id="alertBtn" onclick="toggleAlerts()" style="background: #ffa500; border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-right: 10px;" title="Price Alerts">
                    <i class="fas fa-bell"></i>
                </button>
                <button id="screenshotBtn" onclick="takeScreenshot()" style="background: #4a5568; border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-right: 10px;" title="Screenshot">
                    <i class="fas fa-camera"></i>
                </button>
                <select id="symbol">
                    <option value="R_10">Volatility 10</option>
                    <option value="R_25">Volatility 25</option>
                    <option value="R_50">Volatility 50</option>
                    <option value="R_75">Volatility 75</option>
                    <option value="R_100" selected>Volatility 100</option>
                    <option value="BOOM300">Boom 300</option>
                    <option value="BOOM500">Boom 500</option>
                    <option value="BOOM1000">Boom 1000</option>
                    <option value="CRASH300">Crash 300</option>
                    <option value="CRASH500">Crash 500</option>
                    <option value="CRASH1000">Crash 1000</option>
                    <option value="stpRNG">Step Index</option>
                    <option value="WLDAUD">AUD Basket</option>
                    <option value="WLDEUR">EUR Basket</option>
                    <option value="WLDGBP">GBP Basket</option>
                    <option value="WLDUSD">USD Basket</option>
                    <option value="frxAUDJPY">AUD/JPY</option>
                    <option value="frxAUDUSD">AUD/USD</option>
                    <option value="frxEURGBP">EUR/GBP</option>
                    <option value="frxEURJPY">EUR/JPY</option>
                    <option value="frxEURUSD">EUR/USD</option>
                    <option value="frxGBPJPY">GBP/JPY</option>
                    <option value="frxGBPUSD">GBP/USD</option>
                    <option value="frxUSDCAD">USD/CAD</option>
                    <option value="frxUSDCHF">USD/CHF</option>
                    <option value="frxUSDJPY">USD/JPY</option>
                    <option value="cryBTCUSD">BTC/USD</option>
                    <option value="cryETHUSD">ETH/USD</option>
                    <option value="cryLTCUSD">LTC/USD</option>
                </select>
                <select id="timeframe">
                    <option value="10">10s</option>
                    <option value="30">30s</option>
                    <option value="60" selected>1m</option>
                    <option value="300">5m</option>
                </select>
                <select id="indicators">
                    <option value="">Add Indicator</option>
                    <option value="sma20">SMA 20</option>
                    <option value="sma50">SMA 50</option>
                    <option value="sma100">SMA 100</option>
                    <option value="ema20">EMA 20</option>
                    <option value="ema50">EMA 50</option>
                    <option value="bb">Bollinger Bands</option>
                    <option value="rsi">RSI</option>
                    <option value="macd">MACD</option>
                    <option value="stoch">Stochastic</option>
                    <option value="atr">ATR</option>
                    <option value="create">Create Custom</option>
                    <option value="load">Load Custom</option>
                </select>
                <input type="file" id="customIndicatorFile" accept=".js" style="display: none;">
                <textarea id="customIndicatorCode" style="display: none; width: 400px; height: 300px; background: #1a1a1a; color: #d1d4dc; border: 1px solid #444; font-family: monospace; font-size: 12px;"></textarea>
                <div id="customIndicatorButtons" style="display: none; margin-top: 5px;">
                    <button onclick="saveCustomIndicator()" style="background: #4a5568; border: none; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer; margin-right: 5px;">Save & Add</button>
                    <button onclick="cancelCustomIndicator()" style="background: #666; border: none; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">Cancel</button>
                </div>
            </div>
            
            <div id="activeIndicators">
                <!-- Active indicators will appear here -->
            </div>
            
            <div id="loadingOverlay">
                <div style="text-align: center; color: #d1d4dc;">
                    <div class="loading-spinner"></div>
                    <div style="margin-top: 10px; font-size: 14px;">Loading chart data...</div>
                </div>
            </div>
            
            <canvas id="chart"></canvas>
            
            <!-- Professional Chart Info Panel -->
            <div class="chart-info" id="chartInfo">
                <div class="chart-info-row">
                    <span class="chart-info-label">Open:</span>
                    <span class="chart-info-value" id="infoOpen">-</span>
                </div>
                <div class="chart-info-row">
                    <span class="chart-info-label">High:</span>
                    <span class="chart-info-value" id="infoHigh">-</span>
                </div>
                <div class="chart-info-row">
                    <span class="chart-info-label">Low:</span>
                    <span class="chart-info-value" id="infoLow">-</span>
                </div>
                <div class="chart-info-row">
                    <span class="chart-info-label">Close:</span>
                    <span class="chart-info-value" id="infoClose">-</span>
                </div>
                <div class="chart-info-row">
                    <span class="chart-info-label">Volume:</span>
                    <span class="chart-info-value" id="infoVolume">-</span>
                </div>
            </div>
            
            <!-- Price Alerts Panel -->
            <div id="alertPanel" class="alert-panel">
                <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 10px;">
                    <h4 style="margin: 0; font-size: 14px;">Price Alerts</h4>
                    <button onclick="closeAlerts()" style="background: none; border: none; color: #d1d4dc; cursor: pointer; float: right;">&times;</button>
                </div>
                <div>
                    <input type="number" id="alertPrice" placeholder="Alert Price" step="0.0001" style="width: 100%; background: #1a1a1a; border: 1px solid #444; color: #d1d4dc; padding: 4px; border-radius: 2px; margin-bottom: 5px;">
                    <select id="alertType" style="width: 100%; background: #1a1a1a; border: 1px solid #444; color: #d1d4dc; padding: 4px; border-radius: 2px; margin-bottom: 5px;">
                        <option value="above">Price Above</option>
                        <option value="below">Price Below</option>
                    </select>
                    <button onclick="addAlert()" style="width: 100%; background: #4a5568; border: none; color: white; padding: 6px; border-radius: 4px; cursor: pointer;">Add Alert</button>
                </div>
                <div id="alertsList" style="margin-top: 10px;"></div>
            </div>
        </div>

        <!-- Right Panel - Algo Trading -->
        <div class="w-80 bg-darker border-l border-gray-700 flex flex-col relative z-10">
            <!-- Live Trading -->
            <div class="p-4 border-b border-gray-700">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="font-semibold text-sm">Live Trading</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-400">Demo</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="accountToggle" class="sr-only peer" onchange="toggleAccount()">
                            <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-success"></div>
                        </label>
                        <span class="text-xs text-gray-400">Real</span>
                    </div>
                </div>
                
                <div class="mb-3 p-2 rounded" id="accountStatus">
                    <div class="text-xs text-gray-400">Account Type</div>
                    <div class="font-semibold text-sm" id="accountType">Demo Account</div>
                    <div class="text-xs" id="accountBalance">Balance: $10,000.00</div>
                </div>
                
                <!-- Deriv-style Trading Interface -->
                <div class="space-y-3">
                    <!-- Market Selection -->
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Market</label>
                        <select id="tradeMarket" class="w-full bg-accent border border-gray-600 rounded px-3 py-2 text-sm">
                            <optgroup label="Volatility Indices">
                                <option value="R_10">Volatility 10 Index</option>
                                <option value="R_25">Volatility 25 Index</option>
                                <option value="R_50">Volatility 50 Index</option>
                                <option value="R_75">Volatility 75 Index</option>
                                <option value="R_100" selected>Volatility 100 Index</option>
                            </optgroup>
                            <optgroup label="Crash/Boom Indices">
                                <option value="BOOM300">Boom 300 Index</option>
                                <option value="BOOM500">Boom 500 Index</option>
                                <option value="BOOM1000">Boom 1000 Index</option>
                                <option value="CRASH300">Crash 300 Index</option>
                                <option value="CRASH500">Crash 500 Index</option>
                                <option value="CRASH1000">Crash 1000 Index</option>
                            </optgroup>
                            <optgroup label="Major Pairs">
                                <option value="frxEURUSD">EUR/USD</option>
                                <option value="frxGBPUSD">GBP/USD</option>
                                <option value="frxUSDJPY">USD/JPY</option>
                                <option value="frxAUDUSD">AUD/USD</option>
                            </optgroup>
                            <optgroup label="Cryptocurrencies">
                                <option value="cryBTCUSD">BTC/USD</option>
                                <option value="cryETHUSD">ETH/USD</option>
                            </optgroup>
                        </select>
                    </div>
                    
                    <!-- Trade Type -->
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Trade Type</label>
                        <select id="tradeType" class="w-full bg-accent border border-gray-600 rounded px-3 py-2 text-sm" onchange="updateTradeTypeOptions()">
                            <optgroup label="Up/Down">
                                <option value="CALL">Rise (Call)</option>
                                <option value="PUT">Fall (Put)</option>
                            </optgroup>
                            <optgroup label="Digits">
                                <option value="DIGITEVEN">Even</option>
                                <option value="DIGITODD">Odd</option>
                                <option value="DIGITMATCH">Matches</option>
                                <option value="DIGITDIFF">Differs</option>
                                <option value="DIGITOVER">Over</option>
                                <option value="DIGITUNDER">Under</option>
                            </optgroup>
                            <optgroup label="Touch/No Touch">
                                <option value="ONETOUCH">Touch</option>
                                <option value="NOTOUCH">No Touch</option>
                            </optgroup>
                            <optgroup label="In/Out">
                                <option value="RANGE">Stays Between</option>
                                <option value="UPORDOWN">Goes Outside</option>
                            </optgroup>
                        </select>
                    </div>
                    
                    <!-- Stake Amount -->
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Stake Amount</label>
                        <div class="relative">
                            <input type="number" id="stakeAmount" value="1" min="0.35" step="0.01" 
                                   class="w-full bg-accent border border-gray-600 rounded px-3 py-2 text-sm pr-12">
                            <span class="absolute right-3 top-2 text-xs text-gray-400">USD</span>
                        </div>
                        <div class="flex justify-between mt-1 text-xs text-gray-400">
                            <span>Min: $0.35</span>
                            <span id="maxPayout">Max payout: $1,000</span>
                        </div>
                    </div>
                    
                    <!-- Duration -->
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Duration</label>
                        <div class="grid grid-cols-2 gap-2">
                            <input type="number" id="duration" value="5" min="1" 
                                   class="bg-accent border border-gray-600 rounded px-3 py-2 text-sm">
                            <select id="durationUnit" class="bg-accent border border-gray-600 rounded px-3 py-2 text-sm">
                                <option value="t">Ticks</option>
                                <option value="s">Seconds</option>
                                <option value="m">Minutes</option>
                                <option value="h">Hours</option>
                                <option value="d">Days</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Additional Options for specific trade types -->
                    <div id="additionalOptions" class="hidden">
                        <div id="barrierOptions" class="hidden">
                            <label class="block text-xs text-gray-400 mb-1">Barrier</label>
                            <input type="number" id="barrier" step="0.0001" 
                                   class="w-full bg-accent border border-gray-600 rounded px-3 py-2 text-sm">
                        </div>
                        
                        <div id="digitOptions" class="hidden">
                            <label class="block text-xs text-gray-400 mb-1">Last Digit Prediction</label>
                            <select id="digitPrediction" class="w-full bg-accent border border-gray-600 rounded px-3 py-2 text-sm">
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                                <option value="5">5</option>
                                <option value="6">6</option>
                                <option value="7">7</option>
                                <option value="8">8</option>
                                <option value="9">9</option>
                            </select>
                        </div>
                        
                        <div id="rangeOptions" class="hidden">
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">High Barrier</label>
                                    <input type="number" id="highBarrier" step="0.0001" 
                                           class="w-full bg-accent border border-gray-600 rounded px-2 py-1 text-xs">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Low Barrier</label>
                                    <input type="number" id="lowBarrier" step="0.0001" 
                                           class="w-full bg-accent border border-gray-600 rounded px-2 py-1 text-xs">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Buy Buttons -->
                    <div class="space-y-2">
                        <div class="grid grid-cols-2 gap-2" id="buyButtons">
                            <button id="buyRise" class="bg-success hover:bg-green-600 py-3 rounded text-sm font-semibold transition-colors" onclick="placeTrade('CALL')">
                                <div class="text-xs opacity-75">Buy</div>
                                <div>Rise</div>
                                <div class="text-xs" id="risePrice">$1.00</div>
                            </button>
                            <button id="buyFall" class="bg-danger hover:bg-red-600 py-3 rounded text-sm font-semibold transition-colors" onclick="placeTrade('PUT')">
                                <div class="text-xs opacity-75">Buy</div>
                                <div>Fall</div>
                                <div class="text-xs" id="fallPrice">$1.00</div>
                            </button>
                        </div>
                        
                        <!-- Single button for other trade types -->
                        <button id="singleBuyButton" class="bg-primary hover:bg-orange-600 py-3 px-4 rounded text-sm font-semibold w-full transition-colors hidden" onclick="placeCustomTrade()">
                            <div class="text-xs opacity-75">Buy</div>
                            <div id="singleBuyText">Trade</div>
                            <div class="text-xs" id="singleBuyPrice">$1.00</div>
                        </button>
                    </div>
                    
                    <!-- Trade Summary -->
                    <div class="bg-accent bg-opacity-50 rounded p-2 text-xs">
                        <div class="flex justify-between mb-1">
                            <span class="text-gray-400">Potential Payout:</span>
                            <span id="potentialPayout" class="text-success font-mono">$2.00</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Potential Profit:</span>
                            <span id="potentialProfit" class="text-success font-mono">$1.00</span>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Active Positions -->
            <div class="p-4 border-b border-gray-700">
                <h4 class="font-semibold text-sm mb-3">Open Positions</h4>
                <div id="openPositions" class="text-xs text-gray-400 text-center py-4">
                    You have no open positions.
                </div>
            </div>
            
            <!-- Recent Trades -->
            <div class="flex-1 p-4">
                <h4 class="font-semibold text-sm mb-3">Recent Trades</h4>
                <div id="recentTradesList" class="space-y-2 text-xs">
                    <div class="text-gray-400 text-center py-4">
                        No recent trades.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* ================= CONFIG ================= */
        let SYMBOL = localStorage.getItem('currentSymbol') || "R_100";
        let TIMEFRAME = parseInt(localStorage.getItem('currentTimeframe')) || 60;
        const MAX_CANDLES = 500;

        /* ================= STATE ================= */
        let candles = [];
        let currentCandle = null;
        let ws = null;
        let marketData = new Map();
        let indicators = new Map();
        let backgroundWs = null;
        let symbolCache = new Map();
        let drawings = [];
        let currentDrawing = null;
        let drawingTool = '';
        let isDrawing = false;
        let chartType = 'candles';
        let priceAlerts = [];
        let showAlerts = false;
        let selectedDrawing = null;
        let textInput = null;
        let isEditingText = false;

        /* ================= VIEWPORT ================= */
        let zoom = 1;
        let offset = 0;
        let isDragging = false;
        let lastX = 0;

        /* ================= CANVAS ================= */
        const canvas = document.getElementById("chart");
        const ctx = canvas.getContext("2d");

        function resize() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resize();
        window.addEventListener("resize", resize);

        /* ================= MARKET DATA ================= */
        function initMarketData() {
            const markets = [
                { symbol: 'R_10', price: 1234.56, change: 12.34, changePercent: 1.01, type: 'Volatility' },
                { symbol: 'R_25', price: 2345.67, change: -23.45, changePercent: -0.99, type: 'Volatility' },
                { symbol: 'R_50', price: 3456.78, change: 34.56, changePercent: 1.01, type: 'Volatility' },
                { symbol: 'R_75', price: 4567.89, change: -45.67, changePercent: -0.99, type: 'Volatility' },
                { symbol: 'R_100', price: 5678.90, change: 56.78, changePercent: 1.01, type: 'Volatility' },
                { symbol: 'BOOM300', price: 12345.67, change: 123.45, changePercent: 1.01, type: 'Crash/Boom' },
                { symbol: 'BOOM500', price: 23456.78, change: -234.56, changePercent: -0.99, type: 'Crash/Boom' },
                { symbol: 'BOOM1000', price: 34567.89, change: 345.67, changePercent: 1.01, type: 'Crash/Boom' },
                { symbol: 'CRASH300', price: 45678.90, change: -456.78, changePercent: -0.99, type: 'Crash/Boom' },
                { symbol: 'CRASH500', price: 56789.01, change: 567.89, changePercent: 1.01, type: 'Crash/Boom' },
                { symbol: 'CRASH1000', price: 67890.12, change: -678.90, changePercent: -0.99, type: 'Crash/Boom' },
                { symbol: 'stpRNG', price: 1234.56, change: 12.34, changePercent: 1.01, type: 'Step Index' },
                { symbol: 'WLDAUD', price: 2345.67, change: -23.45, changePercent: -0.99, type: 'Basket' },
                { symbol: 'WLDEUR', price: 3456.78, change: 34.56, changePercent: 1.01, type: 'Basket' },
                { symbol: 'WLDGBP', price: 4567.89, change: -45.67, changePercent: -0.99, type: 'Basket' },
                { symbol: 'WLDUSD', price: 5678.90, change: 56.78, changePercent: 1.01, type: 'Basket' },
                { symbol: 'frxAUDJPY', price: 98.45, change: 0.45, changePercent: 0.46, type: 'Forex' },
                { symbol: 'frxAUDUSD', price: 0.6750, change: 0.0025, changePercent: 0.37, type: 'Forex' },
                { symbol: 'frxEURGBP', price: 0.8650, change: -0.0015, changePercent: -0.17, type: 'Forex' },
                { symbol: 'frxEURJPY', price: 161.25, change: 0.75, changePercent: 0.47, type: 'Forex' },
                { symbol: 'frxEURUSD', price: 1.0850, change: 0.0012, changePercent: 0.11, type: 'Forex' },
                { symbol: 'frxGBPJPY', price: 186.45, change: -0.85, changePercent: -0.45, type: 'Forex' },
                { symbol: 'frxGBPUSD', price: 1.2650, change: -0.0025, changePercent: -0.20, type: 'Forex' },
                { symbol: 'frxUSDCAD', price: 1.3450, change: 0.0035, changePercent: 0.26, type: 'Forex' },
                { symbol: 'frxUSDCHF', price: 0.8950, change: -0.0020, changePercent: -0.22, type: 'Forex' },
                { symbol: 'frxUSDJPY', price: 149.85, change: 0.45, changePercent: 0.30, type: 'Forex' },
                { symbol: 'cryBTCUSD', price: 43250.00, change: 1250.00, changePercent: 2.98, type: 'Crypto' },
                { symbol: 'cryETHUSD', price: 2650.00, change: -85.00, changePercent: -3.11, type: 'Crypto' },
                { symbol: 'cryLTCUSD', price: 72.50, change: 2.25, changePercent: 3.20, type: 'Crypto' }
            ];
            
            markets.forEach(m => marketData.set(m.symbol, m));
            populateMarketList();
        }
        
        function populateMarketList() {
            const marketList = document.getElementById('marketList');
            const markets = Array.from(marketData.values());
            
            marketList.innerHTML = markets.map(item => `
                <div class="market-item p-3 rounded cursor-pointer ${SYMBOL === item.symbol ? 'selected' : ''}" 
                     onclick="selectMarket('${item.symbol}')">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="font-semibold text-sm">${item.symbol}</div>
                            <div class="text-xs text-gray-400">${item.type}</div>
                        </div>
                        <div class="text-right">
                            <div class="font-mono text-sm">${item.price.toFixed(4)}</div>
                            <div class="text-xs ${item.change >= 0 ? 'price-up' : 'price-down'}">
                                ${item.change >= 0 ? '+' : ''}${item.changePercent.toFixed(2)}%
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        function selectMarket(symbol) {
            SYMBOL = symbol;
            localStorage.setItem('currentSymbol', SYMBOL);
            document.getElementById('symbol').value = symbol;
            
            // Sync trading market with selected chart symbol
            const tradeMarket = document.getElementById('tradeMarket');
            if (tradeMarket) {
                tradeMarket.value = symbol;
            }
            
            populateMarketList();
            
            showLoading();
            
            // Use cached data if available for instant loading
            if (symbolCache.has(symbol)) {
                candles = [...symbolCache.get(symbol)];
                draw();
                hideLoading();
            }
            
            restart();
        }

        /* ================= LOADING ================= */
        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'flex';
        }
        
        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        /* ================= BACKGROUND PRICE UPDATES ================= */
        function startBackgroundUpdates() {
            backgroundWs = new WebSocket("wss://ws.derivws.com/websockets/v3?app_id=1089");
            
            backgroundWs.onopen = () => {
                const symbols = Array.from(marketData.keys());
                symbols.forEach(symbol => {
                    backgroundWs.send(JSON.stringify({ ticks: symbol, subscribe: 1 }));
                });
            };
            
            backgroundWs.onmessage = e => {
                const d = JSON.parse(e.data);
                if (d.tick && d.tick.symbol !== SYMBOL) {
                    updateMarketPrice(d.tick.symbol, +d.tick.quote);
                    if (!symbolCache.has(d.tick.symbol)) {
                        symbolCache.set(d.tick.symbol, []);
                    }
                    const cache = symbolCache.get(d.tick.symbol);
                    cache.push({ price: +d.tick.quote, time: d.tick.epoch });
                    if (cache.length > 10) cache.shift();
                }
            };
        }

        /* ================= CONTROLS ================= */
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('symbol').value = SYMBOL;
            document.getElementById('timeframe').value = TIMEFRAME;
            
            document.getElementById("symbol").onchange = e => {
                SYMBOL = e.target.value;
                localStorage.setItem('currentSymbol', SYMBOL);
                
                // Sync trading market with chart symbol
                const tradeMarket = document.getElementById('tradeMarket');
                if (tradeMarket) {
                    tradeMarket.value = SYMBOL;
                }
                
                populateMarketList();
                showLoading();
                restart();
            };

            document.getElementById("timeframe").onchange = e => {
                TIMEFRAME = +e.target.value;
                localStorage.setItem('currentTimeframe', TIMEFRAME);
                showLoading();
                restart();
            };
            
            document.getElementById("indicators").onchange = e => {
                if (e.target.value === 'create') {
                    showCustomIndicatorCreator();
                    e.target.value = "";
                } else if (e.target.value === 'load') {
                    document.getElementById('customIndicatorFile').click();
                    e.target.value = "";
                } else if (e.target.value) {
                    addIndicator(e.target.value);
                    e.target.value = "";
                }
            };
            
            document.getElementById('customIndicatorFile').onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const code = event.target.result;
                            console.log('Loading custom indicator code:', code);
                            const customIndicator = eval(`(${code})`);
                            console.log('Parsed custom indicator:', customIndicator);
                            loadCustomIndicator(customIndicator);
                        } catch (error) {
                            console.error('Error loading custom indicator:', error);
                            alert('Error loading custom indicator: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
        });

        /* ================= WS ================= */
        function connect() {
            ws = new WebSocket("wss://ws.derivws.com/websockets/v3?app_id=1089");

            ws.onopen = () => {
                ws.send(JSON.stringify({
                    ticks_history: SYMBOL,
                    style: "candles",
                    granularity: TIMEFRAME,
                    count: MAX_CANDLES,
                    end: "latest"
                }));
                ws.send(JSON.stringify({ ticks: SYMBOL, subscribe: 1 }));
            };

            ws.onmessage = e => {
                const d = JSON.parse(e.data);
                if (d.error) return;

                if (d.candles) {
                    candles = d.candles.map(c => ({
                        time: Math.floor(c.epoch / TIMEFRAME) * TIMEFRAME,
                        open: +c.open,
                        high: +c.high,
                        low: +c.low,
                        close: +c.close
                    }));
                    currentCandle = null;
                    offset = 0;
                    draw();
                    hideLoading();
                }

                if (d.tick) {
                    updateCandle(+d.tick.quote, d.tick.epoch);
                    updateMarketPrice(SYMBOL, +d.tick.quote);
                }
            };
        }
        
        function updateMarketPrice(symbol, price) {
            const market = marketData.get(symbol);
            if (market) {
                const oldPrice = market.price;
                market.price = price;
                market.change = price - oldPrice;
                market.changePercent = ((price - oldPrice) / oldPrice) * 100;
                populateMarketList();
            }
        }

        function restart() {
            if (ws) ws.close();
            candles = [];
            currentCandle = null;
            zoom = 1;
            offset = 0;
            connect();
        }

        /* ================= CANDLE ENGINE ================= */
        function updateCandle(price, epoch) {
            const t = Math.floor(epoch / TIMEFRAME) * TIMEFRAME;

            if (!currentCandle || currentCandle.time !== t) {
                if (currentCandle) {
                    candles.push(currentCandle);
                    if (candles.length > MAX_CANDLES) candles.shift();
                }
                currentCandle = { time: t, open: price, high: price, low: price, close: price };
            } else {
                currentCandle.high = Math.max(currentCandle.high, price);
                currentCandle.low = Math.min(currentCandle.low, price);
                currentCandle.close = price;
            }
            
            // Check price alerts
            checkAlerts(price);
            
            draw();
        }

        /* ================= INTERACTION ================= */
        canvas.addEventListener("mousedown", e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (drawingTool === 'delete') {
                deleteDrawingAt(x, y);
            } else if (drawingTool) {
                startDrawing(x, y);
            } else {
                isDragging = true;
                lastX = e.clientX;
            }
        });
        
        window.addEventListener("mouseup", e => {
            if (isDrawing) {
                finishDrawing();
            }
            isDragging = false;
        });
        
        window.addEventListener("mousemove", e => {
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                updateDrawing(x, y);
            } else if (isDragging && !drawingTool) {
                offset += (e.clientX - lastX) / 10;
                lastX = e.clientX;
                draw();
            }
        });

        canvas.addEventListener("wheel", e => {
            e.preventDefault();
            zoom += e.deltaY * -0.001;
            zoom = Math.max(0.5, Math.min(3, zoom));
            draw();
        });

        /* ================= CUSTOM INDICATORS ================= */
        let customIndicators = new Map();
        
        function showCustomIndicatorCreator() {
            const template = `({
  name: "My Custom Indicator",
  window: 1, // 1 for main chart, 2 for oscillator window
  color: "#ff0000",
  defaultParams: { period: 14 },
  
  calculate: function(data, params) {
    const period = params.period || 14;
    return data.map((_, i) => {
      if (i < period - 1) return null;
      const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b.close, 0);
      return sum / period;
    });
  },
  
  draw: function(ctx, values, pad, spacing, yFunc, params) {
    ctx.beginPath();
    let started = false;
    values.forEach((val, i) => {
      if (val !== null) {
        const x = pad + i * spacing + spacing / 2;
        const y = yFunc(val);
        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
    });
    ctx.stroke();
  }
})`;
            
            document.getElementById('customIndicatorCode').value = template;
            document.getElementById('customIndicatorCode').style.display = 'block';
            document.getElementById('customIndicatorButtons').style.display = 'block';
        }
        
        function saveCustomIndicator() {
            try {
                const code = document.getElementById('customIndicatorCode').value;
                const customIndicator = eval(`(${code})`);
                loadCustomIndicator(customIndicator);
                cancelCustomIndicator();
            } catch (error) {
                alert('Error in custom indicator code: ' + error.message);
            }
        }
        
        function cancelCustomIndicator() {
            document.getElementById('customIndicatorCode').style.display = 'none';
            document.getElementById('customIndicatorButtons').style.display = 'none';
        }
        
        function loadCustomIndicator(indicator) {
            console.log('Loading indicator:', indicator);
            if (!indicator.name || !indicator.calculate || !indicator.draw) {
                alert('Invalid indicator format. Must have name, calculate, and draw functions.');
                return;
            }
            
            const id = 'custom_' + indicator.name.toLowerCase().replace(/\s+/g, '_');
            customIndicators.set(id, indicator);
            console.log('Custom indicators map:', customIndicators);
            
            // Add to dropdown
            const select = document.getElementById('indicators');
            const option = document.createElement('option');
            option.value = id;
            option.textContent = indicator.name;
            select.appendChild(option);
            
            // Auto-add the indicator
            addIndicator(id);
            
            alert(`Custom indicator "${indicator.name}" loaded successfully!`);
        }
        /* ================= INDICATORS ================= */
        function addIndicator(type) {
            if (indicators.has(type)) return;
            
            if (type.startsWith('custom_')) {
                const customInd = customIndicators.get(type);
                if (customInd) {
                    const params = { 
                        window: customInd.window || 1,
                        ...customInd.defaultParams
                    };
                    
                    indicators.set(type, { 
                        type, 
                        color: customInd.color || '#ffffff',
                        params,
                        custom: customInd
                    });
                }
            } else {
                const params = { 
                    period: getDefaultPeriod(type),
                    shift: 0,
                    method: 'simple',
                    applyTo: 'close',
                    style: 'line',
                    window: getIndicatorWindow(type)
                };
                
                if (type === 'bb') params.std = 2;
                if (type === 'macd') {
                    params.fast = 12;
                    params.slow = 26;
                    params.signal = 9;
                }
                if (type === 'stoch') {
                    params.k = 14;
                    params.d = 3;
                }
                
                indicators.set(type, { 
                    type, 
                    color: getIndicatorColor(type),
                    params
                });
            }
            
            saveIndicatorsToStorage();
            updateIndicatorTags();
            draw();
        }
        
        function removeIndicator(type) {
            indicators.delete(type);
            saveIndicatorsToStorage();
            updateIndicatorTags();
            draw();
        }
        
        function updateIndicatorTags() {
            const container = document.getElementById("activeIndicators");
            container.innerHTML = "";
            indicators.forEach((ind, type) => {
                const tag = document.createElement("span");
                tag.className = "indicator-tag";
                tag.style.position = "relative";
                tag.textContent = getIndicatorName(type);
                tag.onclick = (e) => {
                    e.stopPropagation();
                    showIndicatorEdit(tag, type);
                };
                tag.title = "Click to edit";
                container.appendChild(tag);
            });
        }
        
        function showIndicatorEdit(tag, type) {
            document.querySelectorAll('.indicator-config').forEach(el => el.remove());
            
            const config = document.createElement('div');
            config.className = 'indicator-config';
            config.style.display = 'block';
            
            const ind = indicators.get(type);
            const currentPeriod = ind?.params?.period || getDefaultPeriod(type);
            const currentColor = ind?.color || getIndicatorColor(type);
            
            let configHTML = `<div style="margin-bottom: 8px; font-weight: bold; font-size: 12px;">${getIndicatorName(type)}</div>`;
            
            if (type.startsWith('sma') || type.startsWith('ema')) {
                const currentShift = ind?.params?.shift || 0;
                const currentMethod = ind?.params?.method || 'simple';
                const currentApplyTo = ind?.params?.applyTo || 'close';
                const currentStyle = ind?.params?.style || 'line';
                
                configHTML += `
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Period:</span>
                        <input type="number" class="config-input" id="edit_${type}_period" value="${currentPeriod}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Shift:</span>
                        <input type="number" class="config-input" id="edit_${type}_shift" value="${currentShift}">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Method:</span>
                        <select class="config-input" id="edit_${type}_method">
                            <option value="simple" ${currentMethod === 'simple' ? 'selected' : ''}>Simple</option>
                            <option value="exponential" ${currentMethod === 'exponential' ? 'selected' : ''}>Exponential</option>
                            <option value="smoothed" ${currentMethod === 'smoothed' ? 'selected' : ''}>Smoothed</option>
                            <option value="linear" ${currentMethod === 'linear' ? 'selected' : ''}>Linear</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Apply to:</span>
                        <select class="config-input" id="edit_${type}_applyTo">
                            <option value="close" ${currentApplyTo === 'close' ? 'selected' : ''}>Close</option>
                            <option value="open" ${currentApplyTo === 'open' ? 'selected' : ''}>Open</option>
                            <option value="high" ${currentApplyTo === 'high' ? 'selected' : ''}>High</option>
                            <option value="low" ${currentApplyTo === 'low' ? 'selected' : ''}>Low</option>
                            <option value="median" ${currentApplyTo === 'median' ? 'selected' : ''}>Median</option>
                            <option value="typical" ${currentApplyTo === 'typical' ? 'selected' : ''}>Typical</option>
                            <option value="weighted" ${currentApplyTo === 'weighted' ? 'selected' : ''}>Weighted</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Color:</span>
                        <input type="color" class="config-input" id="edit_${type}_color" value="${currentColor}" style="width: 40px; height: 20px;">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Style:</span>
                        <select class="config-input" id="edit_${type}_style">
                            <option value="line" ${currentStyle === 'line' ? 'selected' : ''}>Line</option>
                            <option value="dashed" ${currentStyle === 'dashed' ? 'selected' : ''}>Dashed</option>
                            <option value="dotted" ${currentStyle === 'dotted' ? 'selected' : ''}>Dotted</option>
                        </select>
                    </div>`;
            } else if (type === 'bb') {
                const currentStd = ind?.params?.std || 2;
                configHTML += `
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Period:</span>
                        <input type="number" class="config-input" id="edit_${type}_period" value="${currentPeriod}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Std Dev:</span>
                        <input type="number" class="config-input" id="edit_${type}_std" value="${currentStd}" min="0.1" step="0.1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Color:</span>
                        <input type="color" class="config-input" id="edit_${type}_color" value="${currentColor}" style="width: 40px; height: 20px;">
                    </div>`;
            } else if (type === 'rsi') {
                configHTML += `
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Period:</span>
                        <input type="number" class="config-input" id="edit_${type}_period" value="${currentPeriod}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Color:</span>
                        <input type="color" class="config-input" id="edit_${type}_color" value="${currentColor}" style="width: 40px; height: 20px;">
                    </div>`;
            } else if (type === 'macd') {
                const currentFast = ind?.params?.fast || 12;
                const currentSlow = ind?.params?.slow || 26;
                const currentSignal = ind?.params?.signal || 9;
                configHTML += `
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Fast:</span>
                        <input type="number" class="config-input" id="edit_${type}_fast" value="${currentFast}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Slow:</span>
                        <input type="number" class="config-input" id="edit_${type}_slow" value="${currentSlow}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Signal:</span>
                        <input type="number" class="config-input" id="edit_${type}_signal" value="${currentSignal}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Color:</span>
                        <input type="color" class="config-input" id="edit_${type}_color" value="${currentColor}" style="width: 40px; height: 20px;">
                    </div>`;
            } else if (type === 'stoch') {
                const currentK = ind?.params?.k || 14;
                const currentD = ind?.params?.d || 3;
                configHTML += `
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">%K Period:</span>
                        <input type="number" class="config-input" id="edit_${type}_k" value="${currentK}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">%D Period:</span>
                        <input type="number" class="config-input" id="edit_${type}_d" value="${currentD}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Color:</span>
                        <input type="color" class="config-input" id="edit_${type}_color" value="${currentColor}" style="width: 40px; height: 20px;">
                    </div>`;
            } else if (type === 'atr') {
                configHTML += `
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Period:</span>
                        <input type="number" class="config-input" id="edit_${type}_period" value="${currentPeriod}" min="1">
                    </div>
                    <div style="margin-bottom: 4px;">
                        <span class="config-label">Color:</span>
                        <input type="color" class="config-input" id="edit_${type}_color" value="${currentColor}" style="width: 40px; height: 20px;">
                    </div>`;
            }
            
            configHTML += `
                <div style="margin-top: 8px;">
                    <button class="config-button" onclick="saveIndicator('${type}')">Save</button>
                    <button class="config-button" onclick="removeIndicator('${type}'); closeEdit()">Remove</button>
                    <button class="config-button" onclick="closeEdit()">Cancel</button>
                </div>`;
            
            config.innerHTML = configHTML;
            tag.appendChild(config);
            
            const inputs = config.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.onclick = (e) => e.stopPropagation();
                input.onkeydown = (e) => e.stopPropagation();
                input.oninput = (e) => e.stopPropagation();
                input.onchange = (e) => e.stopPropagation();
            });
            
            document.addEventListener('click', function closeOnClick(e) {
                if (!config.contains(e.target) && !tag.contains(e.target)) {
                    closeEdit();
                    document.removeEventListener('click', closeOnClick);
                }
            });
        }
        
        function saveIndicator(type) {
            const periodInput = document.getElementById(`edit_${type}_period`);
            const colorInput = document.getElementById(`edit_${type}_color`);
            
            if (periodInput || colorInput) {
                const ind = indicators.get(type);
                const newParams = { ...ind.params };
                
                if (periodInput) newParams.period = parseInt(periodInput.value) || getDefaultPeriod(type);
                
                // MA specific params
                const shiftInput = document.getElementById(`edit_${type}_shift`);
                const methodInput = document.getElementById(`edit_${type}_method`);
                const applyToInput = document.getElementById(`edit_${type}_applyTo`);
                const styleInput = document.getElementById(`edit_${type}_style`);
                
                if (shiftInput) newParams.shift = parseInt(shiftInput.value) || 0;
                if (methodInput) newParams.method = methodInput.value;
                if (applyToInput) newParams.applyTo = applyToInput.value;
                if (styleInput) newParams.style = styleInput.value;
                
                // BB specific params
                const stdInput = document.getElementById(`edit_${type}_std`);
                if (stdInput && type === 'bb') newParams.std = parseFloat(stdInput.value) || 2;
                
                // MACD specific params
                const fastInput = document.getElementById(`edit_${type}_fast`);
                const slowInput = document.getElementById(`edit_${type}_slow`);
                const signalInput = document.getElementById(`edit_${type}_signal`);
                
                if (fastInput) newParams.fast = parseInt(fastInput.value) || 12;
                if (slowInput) newParams.slow = parseInt(slowInput.value) || 26;
                if (signalInput) newParams.signal = parseInt(signalInput.value) || 9;
                
                // Stochastic specific params
                const kInput = document.getElementById(`edit_${type}_k`);
                const dInput = document.getElementById(`edit_${type}_d`);
                
                if (kInput) newParams.k = parseInt(kInput.value) || 14;
                if (dInput) newParams.d = parseInt(dInput.value) || 3;
                
                ind.params = newParams;
                if (colorInput) ind.color = colorInput.value;
                
                saveIndicatorsToStorage();
                updateIndicatorTags();
                closeEdit();
                draw();
            }
        }
        
        function closeEdit() {
            document.querySelectorAll('.indicator-config').forEach(el => el.remove());
        }
        
        function getIndicatorName(type) {
            const ind = indicators.get(type);
            const period = ind?.params?.period;
            
            const baseNames = {
                sma20: "SMA", sma50: "SMA", sma100: "SMA",
                ema20: "EMA", ema50: "EMA",
                bb: "BB", rsi: "RSI", macd: "MACD", stoch: "Stoch", atr: "ATR"
            };
            
            const baseName = baseNames[type] || type.toUpperCase();
            return period ? `${baseName} ${period}` : baseName;
        }
        
        function getDefaultPeriod(type) {
            const defaults = {
                sma20: 20, sma50: 50, sma100: 100,
                ema20: 20, ema50: 50,
                bb: 20, rsi: 14, macd: 12, stoch: 14, atr: 14
            };
            return defaults[type] || 20;
        }
        
        function getIndicatorWindow(type) {
            const windowMap = {
                sma20: 1, sma50: 1, sma100: 1,
                ema20: 1, ema50: 1,
                bb: 1,
                rsi: 2, macd: 2, stoch: 2, atr: 2
            };
            return windowMap[type] || 1;
        }
        
        function getIndicatorColor(type) {
            const colors = { sma20: "#ffa500", sma50: "#00bfff", ema20: "#ff69b4", bb: "#9370db", rsi: "#32cd32" };
            return colors[type] || "#ffffff";
        }
        
        function calculateSMAFromPrices(prices, period) {
            return prices.map((_, i) => {
                if (i < period - 1) return null;
                const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                return sum / period;
            });
        }
        
        function calculateEMAFromPrices(prices, period) {
            const k = 2 / (period + 1);
            const ema = [prices[0] || 0];
            for (let i = 1; i < prices.length; i++) {
                ema[i] = prices[i] * k + ema[i - 1] * (1 - k);
            }
            return ema;
        }
        
        function calculateBB(data, period = 20, std = 2) {
            const sma = data.map((_, i) => {
                if (i < period - 1) return null;
                const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b.close, 0);
                return sum / period;
            });
            
            return data.map((_, i) => {
                if (i < period - 1) return null;
                const slice = data.slice(i - period + 1, i + 1);
                const mean = sma[i];
                const variance = slice.reduce((sum, c) => sum + Math.pow(c.close - mean, 2), 0) / period;
                const stdDev = Math.sqrt(variance);
                return { upper: mean + stdDev * std, middle: mean, lower: mean - stdDev * std };
            });
        }
        
        function calculateRSI(data, period = 14) {
            const changes = data.slice(1).map((c, i) => c.close - data[i].close);
            const gains = changes.map(c => c > 0 ? c : 0);
            const losses = changes.map(c => c < 0 ? -c : 0);
            
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
            
            const rsi = [null];
            for (let i = 0; i < period; i++) rsi.push(null);
            
            for (let i = period; i < changes.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                const rs = avgGain / (avgLoss || 0.001);
                rsi.push(100 - (100 / (1 + rs)));
            }
            return rsi;
        }
        
        function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const fastEMA = calculateEMAFromPrices(data.map(c => c.close), fastPeriod);
            const slowEMA = calculateEMAFromPrices(data.map(c => c.close), slowPeriod);
            
            const macdLine = fastEMA.map((fast, i) => {
                if (fast === null || slowEMA[i] === null) return null;
                return fast - slowEMA[i];
            });
            
            const signalLine = calculateEMAFromPrices(macdLine.filter(v => v !== null), signalPeriod);
            let signalIndex = 0;
            const signal = macdLine.map(v => v === null ? null : signalLine[signalIndex++] || null);
            
            const histogram = macdLine.map((macd, i) => {
                if (macd === null || signal[i] === null) return null;
                return macd - signal[i];
            });
            
            return { macd: macdLine, signal, histogram };
        }
        
        function calculateStochastic(data, kPeriod = 14, dPeriod = 3) {
            const stochK = data.map((_, i) => {
                if (i < kPeriod - 1) return null;
                const slice = data.slice(i - kPeriod + 1, i + 1);
                const highest = Math.max(...slice.map(c => c.high));
                const lowest = Math.min(...slice.map(c => c.low));
                const current = data[i].close;
                return ((current - lowest) / (highest - lowest)) * 100;
            });
            
            const stochD = calculateSMAFromPrices(stochK.filter(v => v !== null), dPeriod);
            let dIndex = 0;
            const d = stochK.map(v => v === null ? null : stochD[dIndex++] || null);
            
            return { k: stochK, d };
        }
        
        function calculateATR(data, period = 14) {
            const trueRanges = data.slice(1).map((c, i) => {
                const prev = data[i];
                return Math.max(
                    c.high - c.low,
                    Math.abs(c.high - prev.close),
                    Math.abs(c.low - prev.close)
                );
            });
            
            const atr = [null];
            let sum = trueRanges.slice(0, period).reduce((a, b) => a + b, 0);
            atr.push(sum / period);
            
            for (let i = period; i < trueRanges.length; i++) {
                const prevATR = atr[atr.length - 1];
                const newATR = (prevATR * (period - 1) + trueRanges[i]) / period;
                atr.push(newATR);
            }
            
            return atr;
        }
        
        /* ================= DRAW ================= */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let data = [...candles];
            if (currentCandle) data.push(currentCandle);
            if (!data.length) return;

            const pad = 70;
            const w = canvas.width - pad * 2;
            const totalH = canvas.height - pad * 2;
            
            // Check if we have window 2 indicators
            const hasWindow2 = Array.from(indicators.values()).some(ind => ind.params?.window === 2);
            const window1H = hasWindow2 ? totalH * 0.7 : totalH;
            const window2H = hasWindow2 ? totalH * 0.3 : 0;
            const window2Y = pad + window1H;

            const candleSpacing = 6 * zoom;
            const visible = Math.floor(w / candleSpacing);
            const start = Math.max(0, data.length - visible - Math.floor(offset));
            const view = data.slice(start, start + visible);

            // Window 1 (Price chart)
            const max1 = Math.max(...view.map(c => c.high));
            const min1 = Math.min(...view.map(c => c.low));
            const range1 = max1 - min1 || 1;
            const y1 = p => pad + window1H - ((p - min1) / range1) * window1H;

            // Grid for window 1
            ctx.strokeStyle = "#1f2430";
            for (let i = 0; i <= 5; i++) {
                const gy = pad + (window1H / 5) * i;
                ctx.beginPath();
                ctx.moveTo(pad, gy);
                ctx.lineTo(canvas.width - pad, gy);
                ctx.stroke();
            }

            // Draw candles
            drawChart(view, pad, candleSpacing, y1, window1H);
            
            // Window 2 setup
            let y2 = null;
            if (hasWindow2) {
                // Grid for window 2
                ctx.strokeStyle = "#1f2430";
                for (let i = 0; i <= 3; i++) {
                    const gy = window2Y + (window2H / 3) * i;
                    ctx.beginPath();
                    ctx.moveTo(pad, gy);
                    ctx.lineTo(canvas.width - pad, gy);
                    ctx.stroke();
                }
                
                // Separator line
                ctx.strokeStyle = "#444";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pad, window2Y);
                ctx.lineTo(canvas.width - pad, window2Y);
                ctx.stroke();
                ctx.lineWidth = 1;
                
                y2 = val => window2Y + window2H - ((val / 100) * window2H);
            }

            // Draw indicators
            indicators.forEach((ind, type) => {
                const period = ind.params?.period || getDefaultPeriod(type);
                const shift = ind.params?.shift || 0;
                const applyTo = ind.params?.applyTo || 'close';
                const style = ind.params?.style || 'line';
                const window = ind.params?.window || 1;
                
                ctx.strokeStyle = ind.color;
                ctx.lineWidth = 1;
                
                if (style === 'dashed') {
                    ctx.setLineDash([5, 5]);
                } else if (style === 'dotted') {
                    ctx.setLineDash([2, 2]);
                } else {
                    ctx.setLineDash([]);
                }
                
                const priceData = data.map(c => {
                    switch(applyTo) {
                        case 'open': return c.open;
                        case 'high': return c.high;
                        case 'low': return c.low;
                        case 'median': return (c.high + c.low) / 2;
                        case 'typical': return (c.high + c.low + c.close) / 3;
                        case 'weighted': return (c.high + c.low + c.close + c.close) / 4;
                        default: return c.close;
                    }
                });
                
                if (type.startsWith('sma') && window === 1) {
                    const sma = calculateSMAFromPrices(priceData, period);
                    const shiftedSma = shift ? sma.slice(shift).concat(new Array(shift).fill(null)) : sma;
                    const visibleSma = shiftedSma.slice(start, start + visible);
                    drawLine(visibleSma, pad, candleSpacing, y1);
                } else if (type.startsWith('ema') && window === 1) {
                    const ema = calculateEMAFromPrices(priceData, period);
                    const shiftedEma = shift ? ema.slice(shift).concat(new Array(shift).fill(null)) : ema;
                    const visibleEma = shiftedEma.slice(start, start + visible);
                    drawLine(visibleEma, pad, candleSpacing, y1);
                } else if (type === 'bb' && window === 1) {
                    const std = ind.params?.std || 2;
                    const bb = calculateBB(data, period, std);
                    const visibleBb = bb.slice(start, start + visible);
                    visibleBb.forEach((b, i) => {
                        if (b) {
                            const x = pad + i * candleSpacing + candleSpacing / 2;
                            ctx.strokeStyle = ind.color;
                            ctx.globalAlpha = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(x, y1(b.upper));
                            ctx.lineTo(x, y1(b.lower));
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                            ctx.beginPath();
                            ctx.moveTo(x-1, y1(b.middle));
                            ctx.lineTo(x+1, y1(b.middle));
                            ctx.stroke();
                        }
                    });
                } else if (type === 'rsi' && window === 2 && y2) {
                    const rsi = calculateRSI(data, period);
                    const visibleRsi = rsi.slice(start, start + visible);
                    drawLine(visibleRsi, pad, candleSpacing, y2);
                } else if (type === 'macd' && window === 2 && y2) {
                    const fast = ind.params?.fast || 12;
                    const slow = ind.params?.slow || 26;
                    const signal = ind.params?.signal || 9;
                    const macd = calculateMACD(data, fast, slow, signal);
                    const visibleMacd = macd.macd.slice(start, start + visible);
                    const visibleSignal = macd.signal.slice(start, start + visible);
                    
                    // Scale MACD to window 2
                    const macdValues = [...visibleMacd, ...visibleSignal].filter(v => v !== null);
                    const macdMax = Math.max(...macdValues);
                    const macdMin = Math.min(...macdValues);
                    const macdRange = macdMax - macdMin || 1;
                    const macdY = val => val ? window2Y + window2H - (((val - macdMin) / macdRange) * window2H) : null;
                    
                    ctx.strokeStyle = ind.color;
                    drawLine(visibleMacd, pad, candleSpacing, macdY);
                    ctx.strokeStyle = '#ff6600';
                    drawLine(visibleSignal, pad, candleSpacing, macdY);
                } else if (type === 'stoch' && window === 2 && y2) {
                    const k = ind.params?.k || 14;
                    const d = ind.params?.d || 3;
                    const stoch = calculateStochastic(data, k, d);
                    const visibleK = stoch.k.slice(start, start + visible);
                    const visibleD = stoch.d.slice(start, start + visible);
                    
                    ctx.strokeStyle = ind.color;
                    drawLine(visibleK, pad, candleSpacing, y2);
                    ctx.strokeStyle = '#ff6600';
                    drawLine(visibleD, pad, candleSpacing, y2);
                } else if (type === 'atr' && window === 2 && y2) {
                    const atr = calculateATR(data, period);
                    const visibleAtr = atr.slice(start, start + visible);
                    
                    // Scale ATR to window 2
                    const atrValues = visibleAtr.filter(v => v !== null);
                    const atrMax = Math.max(...atrValues);
                    const atrMin = Math.min(...atrValues);
                    const atrRange = atrMax - atrMin || 1;
                    const atrY = val => val ? window2Y + window2H - (((val - atrMin) / atrRange) * window2H) : null;
                    
                    drawLine(visibleAtr, pad, candleSpacing, atrY);
                } else if (type.startsWith('custom_') && ind.custom && window === ind.params?.window) {
                    try {
                        if (ind.custom && typeof ind.custom.calculate === 'function') {
                            const result = ind.custom.calculate(data, ind.params);
                            const visibleResult = Array.isArray(result) ? result.slice(start, start + visible) : result;
                            
                            ctx.strokeStyle = ind.color;
                            ctx.lineWidth = 1;
                            if (window === 1) {
                                ind.custom.draw(ctx, visibleResult, pad, candleSpacing, y1, ind.params);
                            } else if (window === 2 && y2) {
                                ind.custom.draw(ctx, visibleResult, pad, candleSpacing, y2, ind.params);
                            }
                        }
                    } catch (error) {
                        console.error('Custom indicator error:', error);
                        // Remove broken custom indicator
                        indicators.delete(type);
                        updateIndicatorTags();
                    }
                }
                
                ctx.setLineDash([]);
            });
            
            // Draw drawings on top
            drawDrawings();
        }
        
        function drawLine(values, pad, spacing, yFunc) {
            ctx.beginPath();
            let started = false;
            values.forEach((val, i) => {
                if (val !== null) {
                    const x = pad + i * spacing + spacing / 2;
                    if (!started) {
                        ctx.moveTo(x, yFunc(val));
                        started = true;
                    } else {
                        ctx.lineTo(x, yFunc(val));
                    }
                }
            });
            ctx.stroke();
        }

        /* ================= PROFESSIONAL FEATURES ================= */
        function initProfessionalFeatures() {
            updateNavPriceTicker();
            updateConnectionStatus();
            updateChartInfo();
            setInterval(updateNavPriceTicker, 2000);
            setInterval(updateChartInfo, 1000);
        }
        
        function updateNavPriceTicker() {
            const ticker = document.getElementById('navPriceTicker');
            if (!ticker) return;
            const markets = Array.from(marketData.values()).slice(0, 6);
            
            ticker.innerHTML = markets.map(market => `
                <div class="nav-ticker-item">
                    <span class="nav-ticker-symbol">${market.symbol}</span>
                    <span class="nav-ticker-price">${market.price.toFixed(4)}</span>
                    <span class="nav-ticker-change ${market.change >= 0 ? 'nav-ticker-up' : 'nav-ticker-down'}">
                        ${market.change >= 0 ? '+' : ''}${market.changePercent.toFixed(2)}%
                    </span>
                </div>
            `).join('');
        }

        
        function updateConnectionStatus() {
            const status = document.getElementById('connectionStatus');
            const isConnected = ws && ws.readyState === WebSocket.OPEN;
            
            if (isConnected) {
                status.className = 'connection-status status-connected';
                status.innerHTML = '<div class="status-dot"></div><span>Live</span>';
            } else {
                status.className = 'connection-status status-disconnected';
                status.innerHTML = '<div class="status-dot"></div><span>Offline</span>';
            }
        }
        
        function updateChartInfo() {
            const latest = currentCandle || (candles.length > 0 ? candles[candles.length - 1] : null);
            if (!latest) return;
            
            const infoOpen = document.getElementById('infoOpen');
            const infoHigh = document.getElementById('infoHigh');
            const infoLow = document.getElementById('infoLow');
            const infoClose = document.getElementById('infoClose');
            const infoVolume = document.getElementById('infoVolume');
            
            if (infoOpen) infoOpen.textContent = latest.open.toFixed(4);
            if (infoHigh) infoHigh.textContent = latest.high.toFixed(4);
            if (infoLow) infoLow.textContent = latest.low.toFixed(4);
            if (infoClose) infoClose.textContent = latest.close.toFixed(4);
            if (infoVolume) infoVolume.textContent = Math.floor(Math.random() * 10000);
        }
        
        function showNotification(message, type = 'info') {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            container.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => container.removeChild(notification), 300);
            }, 3000);
        }
        let derivWS = null;
        let authToken = null;
        let isRealAccount = false;
        let demoBalance = 10000;
        let realBalance = 1000;
        
        function getCurrentBalance() {
            return isRealAccount ? realBalance : demoBalance;
        }
        
        function updateTradeTypeOptions() {
            const tradeType = document.getElementById('tradeType').value;
            
            // Save trade type to localStorage
            localStorage.setItem('selectedTradeType', tradeType);
            
            const additionalOptions = document.getElementById('additionalOptions');
            const barrierOptions = document.getElementById('barrierOptions');
            const digitOptions = document.getElementById('digitOptions');
            const rangeOptions = document.getElementById('rangeOptions');
            const buyButtons = document.getElementById('buyButtons');
            const singleBuyButton = document.getElementById('singleBuyButton');
            const singleBuyText = document.getElementById('singleBuyText');
            
            // Hide all additional options first
            additionalOptions.classList.add('hidden');
            barrierOptions.classList.add('hidden');
            digitOptions.classList.add('hidden');
            rangeOptions.classList.add('hidden');
            
            // Show appropriate buttons based on trade type
            if (tradeType === 'CALL' || tradeType === 'PUT') {
                buyButtons.classList.remove('hidden');
                singleBuyButton.classList.add('hidden');
            } else {
                buyButtons.classList.add('hidden');
                singleBuyButton.classList.remove('hidden');
                
                // Update single button text based on trade type
                const tradeTypeNames = {
                    'DIGITEVEN': 'Even',
                    'DIGITODD': 'Odd',
                    'DIGITMATCH': 'Matches',
                    'DIGITDIFF': 'Differs',
                    'DIGITOVER': 'Over',
                    'DIGITUNDER': 'Under',
                    'ONETOUCH': 'Touch',
                    'NOTOUCH': 'No Touch',
                    'RANGE': 'Stays Between',
                    'UPORDOWN': 'Goes Outside'
                };
                
                singleBuyText.textContent = tradeTypeNames[tradeType] || 'Trade';
                
                // Show additional options for specific trade types
                if (['DIGITMATCH', 'DIGITDIFF', 'DIGITOVER', 'DIGITUNDER'].includes(tradeType)) {
                    additionalOptions.classList.remove('hidden');
                    digitOptions.classList.remove('hidden');
                } else if (['ONETOUCH', 'NOTOUCH'].includes(tradeType)) {
                    additionalOptions.classList.remove('hidden');
                    barrierOptions.classList.remove('hidden');
                } else if (['RANGE', 'UPORDOWN'].includes(tradeType)) {
                    additionalOptions.classList.remove('hidden');
                    rangeOptions.classList.remove('hidden');
                }
            }
            
            updatePricing();
        }
        
        function updatePricing() {
            const stake = parseFloat(document.getElementById('stakeAmount').value) || 1;
            const tradeType = document.getElementById('tradeType').value;
            
            // Calculate potential payout (simplified calculation)
            let multiplier = 1.85; // Default multiplier
            
            // Adjust multiplier based on trade type
            switch(tradeType) {
                case 'CALL':
                case 'PUT':
                    multiplier = 1.85;
                    break;
                case 'DIGITEVEN':
                case 'DIGITODD':
                    multiplier = 1.95;
                    break;
                case 'DIGITMATCH':
                case 'DIGITDIFF':
                    multiplier = 9.5;
                    break;
                case 'DIGITOVER':
                case 'DIGITUNDER':
                    multiplier = 1.9;
                    break;
                case 'ONETOUCH':
                case 'NOTOUCH':
                    multiplier = 2.5;
                    break;
                case 'RANGE':
                case 'UPORDOWN':
                    multiplier = 2.2;
                    break;
            }
            
            const payout = stake * multiplier;
            const profit = payout - stake;
            
            // Update UI elements
            document.getElementById('potentialPayout').textContent = `$${payout.toFixed(2)}`;
            document.getElementById('potentialProfit').textContent = `$${profit.toFixed(2)}`;
            document.getElementById('maxPayout').textContent = `Max payout: $${Math.min(payout * 10, 50000).toFixed(0)}`;
            
            // Update button prices
            document.getElementById('risePrice').textContent = `$${stake.toFixed(2)}`;
            document.getElementById('fallPrice').textContent = `$${stake.toFixed(2)}`;
            document.getElementById('singleBuyPrice').textContent = `$${stake.toFixed(2)}`;
        }
        
        // Update pricing when stake amount changes
        document.addEventListener('DOMContentLoaded', function() {
            const stakeInput = document.getElementById('stakeAmount');
            if (stakeInput) {
                stakeInput.addEventListener('input', updatePricing);
                stakeInput.addEventListener('change', updatePricing);
            }
            
            // Restore saved trade type on page load
            const savedTradeType = localStorage.getItem('selectedTradeType');
            const tradeTypeSelect = document.getElementById('tradeType');
            if (savedTradeType && tradeTypeSelect) {
                tradeTypeSelect.value = savedTradeType;
            }
            
            // Initialize trade type options
            updateTradeTypeOptions();
            updatePricing();
        });
        
        async function toggleAccount() {
            const wantReal = document.getElementById('accountToggle').checked;
            const token = localStorage.getItem('authToken') || localStorage.getItem('jwt_token') || localStorage.getItem('token');
            
            // Save user's account preference
            localStorage.setItem('preferredAccountType', wantReal ? 'real' : 'demo');
            
            if (!token) {
                console.log('No auth token found, using local demo mode');
                isRealAccount = false;
                document.getElementById('accountToggle').checked = false;
                updateAccountDisplay();
                return;
            }
            
            try {
                const accountType = wantReal ? 'real' : 'demo';
                const response = await fetch(`/api/deriv/token?account_type=${accountType}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.has_token && data.token) {
                        connectDeriv(data.token, accountType === 'demo');
                        isRealAccount = wantReal;
                    } else {
                        isRealAccount = false;
                        document.getElementById('accountToggle').checked = false;
                        alert(`No ${accountType} token found. Please add your Deriv API token in Settings.`);
                    }
                } else {
                    isRealAccount = false;
                    document.getElementById('accountToggle').checked = false;
                    console.log('Token fetch failed, using local demo mode');
                }
            } catch (error) {
                isRealAccount = false;
                document.getElementById('accountToggle').checked = false;
                console.log('Network error, using local demo mode:', error);
            }
            
            updateAccountDisplay();
        }
        
        function updateAccountDisplay() {
            const accountType = document.getElementById('accountType');
            const accountBalance = document.getElementById('accountBalance');
            const accountStatus = document.getElementById('accountStatus');
            const topBalance = document.getElementById('topAccountBalance');
            
            const currentBalance = getCurrentBalance();
            
            // Cache balance for faster loading next time
            const accountTypeStr = isRealAccount ? 'real' : 'demo';
            localStorage.setItem(`${accountTypeStr}Balance`, currentBalance.toString());
            
            if (isRealAccount) {
                accountType.textContent = 'Real Account';
                accountStatus.className = 'mb-3 p-2 rounded bg-red-900 bg-opacity-30 border border-red-600';
                accountBalance.textContent = `Balance: $${currentBalance.toFixed(2)}`;
                document.getElementById('accountToggle').checked = true;
            } else {
                accountType.textContent = 'Demo Account';
                accountStatus.className = 'mb-3 p-2 rounded bg-blue-900 bg-opacity-30 border border-blue-600';
                accountBalance.textContent = `Balance: $${currentBalance.toFixed(2)}`;
                document.getElementById('accountToggle').checked = false;
            }
            
            if (topBalance) {
                topBalance.textContent = `$${currentBalance.toFixed(2)}`;
            }
        }
        
        // Initialize account display on page load
        async function initializeAccountDisplay() {
            const token = localStorage.getItem('authToken') || localStorage.getItem('jwt_token') || localStorage.getItem('token');
            const preferredType = localStorage.getItem('preferredAccountType') || 'demo';
            
            // Sync initial trading market with chart symbol
            const tradeMarket = document.getElementById('tradeMarket');
            if (tradeMarket) {
                tradeMarket.value = SYMBOL;
            }
            
            // Show cached balance immediately for better UX
            const cachedBalance = localStorage.getItem(`${preferredType}Balance`);
            if (cachedBalance) {
                if (preferredType === 'demo') {
                    demoBalance = parseFloat(cachedBalance);
                } else {
                    realBalance = parseFloat(cachedBalance);
                }
                isRealAccount = preferredType === 'real';
                updateAccountDisplay();
            }
            
            if (!token) {
                console.log('No auth token found, using local demo mode');
                isRealAccount = false;
                updateAccountDisplay();
                return;
            }
            
            try {
                const response = await fetch(`/api/deriv/token?account_type=${preferredType}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.has_token && data.token) {
                        connectDeriv(data.token, preferredType === 'demo');
                        isRealAccount = preferredType === 'real';
                    } else {
                        isRealAccount = false;
                    }
                } else {
                    isRealAccount = false;
                }
            } catch (error) {
                isRealAccount = false;
                console.log('Failed to initialize account, using local demo:', error);
            }
            
            updateAccountDisplay();
        }
        
        function connectDeriv(token, isDemo = true) {
            const endpoint = 'wss://ws.binaryws.com/websockets/v3?app_id=1089';
                
            derivWS = new WebSocket(endpoint);
            
            derivWS.onopen = () => {
                console.log(`Connected to Deriv ${isDemo ? 'Demo' : 'Real'} API`);
                derivWS.send(JSON.stringify({ authorize: token }));
            };
            
            derivWS.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleDerivResponse(data);
            };
            
            // Auto-reconnect on close
            derivWS.onclose = () => {
                setTimeout(() => connectDeriv(token, isDemo), 3000);
            };
        }
        
        function handleDerivResponse(data) {
            if (data.error) {
                alert('Trade Error: ' + data.error.message);
                return;
            }
            
            if (data.authorize) {
                authToken = data.authorize.token;
                const balance = data.authorize.balance || 0;
                
                // Update the correct account balance based on account type
                if (data.authorize.is_virtual === 1) {
                    demoBalance = balance;
                    if (!isRealAccount) {
                        updateAccountDisplay();
                    }
                } else {
                    realBalance = balance;
                    if (isRealAccount) {
                        updateAccountDisplay();
                    }
                }
                
                // Subscribe to balance updates for real-time changes
                derivWS.send(JSON.stringify({ balance: 1, subscribe: 1 }));
            }
            
            if (data.balance) {
                const balance = data.balance.balance;
                const isVirtual = data.balance.is_virtual === 1;
                
                // Update the correct balance and refresh display immediately
                if (isVirtual) {
                    demoBalance = balance;
                } else {
                    realBalance = balance;
                }
                
                updateAccountDisplay();
            }
            
            if (data.buy) {
                const trade = {
                    id: data.buy.contract_id,
                    symbol: data.buy.shortcode,
                    type: data.buy.transaction_id,
                    stake: data.buy.buy_price,
                    time: new Date().toLocaleTimeString()
                };
                addLiveTrade(trade);
                alert(`Trade placed successfully! Contract ID: ${data.buy.contract_id}`);
                
                // Balance will update automatically via subscription
            }
        }
        
        function placeTrade(tradeType) {
            const market = document.getElementById('tradeMarket').value;
            const stake = parseFloat(document.getElementById('stakeAmount').value);
            const duration = parseInt(document.getElementById('duration').value);
            const durationUnit = document.getElementById('durationUnit').value;
            
            if (!derivWS || derivWS.readyState !== WebSocket.OPEN) {
                // Simulate trade for demo purposes when not connected to Deriv
                simulateTrade(tradeType, market, stake, duration, durationUnit);
                return;
            }
            
            const currentBalance = getCurrentBalance();
            if (stake > currentBalance) {
                alert('Insufficient balance for this trade.');
                return;
            }
            
            const tradeRequest = {
                buy: 1,
                price: stake,
                parameters: {
                    contract_type: tradeType,
                    symbol: market,
                    duration: duration,
                    duration_unit: durationUnit,
                    currency: 'USD',
                    amount: stake,
                    basis: 'stake'
                }
            };
            
            // Add additional parameters based on trade type
            const additionalParams = getAdditionalTradeParams(tradeType);
            Object.assign(tradeRequest.parameters, additionalParams);
            
            console.log('Sending trade request:', tradeRequest);
            derivWS.send(JSON.stringify(tradeRequest));
        }
        
        function getAdditionalTradeParams(tradeType) {
            const params = {};
            
            switch(tradeType) {
                case 'DIGITMATCH':
                case 'DIGITDIFF':
                case 'DIGITOVER':
                case 'DIGITUNDER':
                    const digitPrediction = document.getElementById('digitPrediction').value;
                    if (digitPrediction) {
                        params.last_digit_prediction = parseInt(digitPrediction);
                    }
                    break;
                    
                case 'ONETOUCH':
                case 'NOTOUCH':
                    const barrier = document.getElementById('barrier').value;
                    if (barrier) {
                        params.barrier = parseFloat(barrier);
                    }
                    break;
                    
                case 'RANGE':
                case 'UPORDOWN':
                    const highBarrier = document.getElementById('highBarrier').value;
                    const lowBarrier = document.getElementById('lowBarrier').value;
                    if (highBarrier && lowBarrier) {
                        params.barrier = parseFloat(highBarrier);
                        params.barrier2 = parseFloat(lowBarrier);
                    }
                    break;
            }
            
            return params;
        }
        
        function simulateTrade(tradeType, market, stake, duration, durationUnit) {
            // Show professional notification
            showNotification(`Trade placed: ${tradeType} on ${market} for $${stake}`, 'success');
            
            // Simulate trade execution for demo purposes
            const tradeTypeNames = {
                'CALL': 'Rise',
                'PUT': 'Fall',
                'DIGITEVEN': 'Even',
                'DIGITODD': 'Odd',
                'DIGITMATCH': 'Matches',
                'DIGITDIFF': 'Differs',
                'DIGITOVER': 'Over',
                'DIGITUNDER': 'Under',
                'ONETOUCH': 'Touch',
                'NOTOUCH': 'No Touch',
                'RANGE': 'Stays Between',
                'UPORDOWN': 'Goes Outside'
            };
            
            const tradeName = tradeTypeNames[tradeType] || tradeType;
            const contractId = 'DEMO_' + Date.now();
            
            // Update balance
            if (isRealAccount) {
                realBalance -= stake;
            } else {
                demoBalance -= stake;
            }
            updateAccountDisplay();
            
            // Add to recent trades
            const trade = {
                id: contractId,
                symbol: market,
                type: tradeName,
                stake: stake,
                time: new Date().toLocaleTimeString()
            };
            addLiveTrade(trade);
            
            // Simulate trade outcome after duration (for demo)
            setTimeout(() => {
                simulateTradeOutcome(trade);
            }, Math.min(duration * 1000, 10000)); // Max 10 seconds for demo
        }
        
        function simulateTradeOutcome(trade) {
            // Random outcome for demo
            const isWin = Math.random() > 0.4; // 60% win rate for demo
            const multiplier = isWin ? 1.85 : 0; // Simplified payout
            const payout = trade.stake * multiplier;
            const profit = payout - trade.stake;
            
            if (isWin && payout > 0) {
                if (isRealAccount) {
                    realBalance += payout;
                } else {
                    demoBalance += payout;
                }
                updateAccountDisplay();
                
                // Update recent trades with outcome
                updateTradeOutcome(trade.id, profit, true);
                
                // Professional notification
                showNotification(`Trade Won! Profit: $${profit.toFixed(2)}`, 'success');
            } else {
                updateTradeOutcome(trade.id, -trade.stake, false);
                showNotification(`Trade Lost: -$${trade.stake.toFixed(2)}`, 'error');
            }
        }
        
        function updateTradeOutcome(tradeId, profit, isWin) {
            // Find and update the trade in recent trades display
            const recentTrades = document.getElementById('recentTradesList');
            const tradeElements = recentTrades.querySelectorAll('.bg-accent');
            
            tradeElements.forEach(element => {
                const profitElement = element.querySelector('.text-warning, .text-danger, .text-success');
                if (profitElement && profitElement.textContent.includes('Stake')) {
                    const parentDiv = profitElement.parentElement;
                    parentDiv.innerHTML = `
                        <div class="${profit >= 0 ? 'text-success' : 'text-danger'} font-mono">${profit >= 0 ? '+' : ''}$${profit.toFixed(2)}</div>
                        <div class="text-gray-400 text-xs">${profit >= 0 ? 'Profit' : 'Loss'}</div>
                    `;
                }
            });
        }
        
        function placeCustomTrade() {
            const tradeType = document.getElementById('tradeType').value;
            placeTrade(tradeType);
        }
        
        function addLiveTrade(trade) {
            const recentTrades = document.getElementById('recentTradesList');
            
            // Remove "No recent trades" message if it exists
            const noTradesMsg = recentTrades.querySelector('.text-gray-400');
            if (noTradesMsg && noTradesMsg.textContent.includes('No recent trades')) {
                noTradesMsg.remove();
            }
            
            // Clean up trade display
            const cleanSymbol = trade.symbol.replace(/^(R_|BOOM|CRASH|frx|cry)/, '');
            const tradeTypeDisplay = trade.type.replace(/DIGIT|CALL|PUT/, match => {
                switch(match) {
                    case 'DIGIT': return 'Digit';
                    case 'CALL': return 'Rise';
                    case 'PUT': return 'Fall';
                    default: return match;
                }
            });
            
            const tradeEl = document.createElement('div');
            tradeEl.className = 'bg-accent rounded p-3';
            tradeEl.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <div>
                        <div class="font-medium">${cleanSymbol} ${tradeTypeDisplay}</div>
                        <div class="text-gray-400 text-xs">${trade.time}</div>
                    </div>
                    <div class="text-right">
                        <div class="text-warning font-mono">-$${trade.stake.toFixed(2)}</div>
                        <div class="text-gray-400 text-xs">Stake</div>
                    </div>
                </div>
            `;
            
            recentTrades.insertBefore(tradeEl, recentTrades.firstChild);
            if (recentTrades.children.length > 5) {
                recentTrades.removeChild(recentTrades.lastChild);
            }
        }
        
        /* ================= PERSISTENCE ================= */
        function saveIndicatorsToStorage() {
            const indicatorData = Array.from(indicators.entries());
            const customData = Array.from(customIndicators.entries());
            localStorage.setItem('tradingIndicators', JSON.stringify(indicatorData));
            localStorage.setItem('customIndicators', JSON.stringify(customData));
        }
        
        function loadIndicatorsFromStorage() {
            // Load custom indicators first
            const savedCustom = localStorage.getItem('customIndicators');
            if (savedCustom) {
                const customData = JSON.parse(savedCustom);
                customData.forEach(([key, value]) => {
                    // Restore functions from string
                    if (typeof value.calculate === 'string') {
                        value.calculate = eval(`(${value.calculate})`);
                    }
                    if (typeof value.draw === 'string') {
                        value.draw = eval(`(${value.draw})`);
                    }
                    
                    customIndicators.set(key, value);
                    // Add to dropdown
                    const select = document.getElementById('indicators');
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = value.name;
                    select.appendChild(option);
                });
            }
            
            // Load active indicators
            const saved = localStorage.getItem('tradingIndicators');
            if (saved) {
                const indicatorData = JSON.parse(saved);
                indicators.clear();
                indicatorData.forEach(([key, value]) => {
                    if (key.startsWith('custom_') && !customIndicators.has(key)) {
                        return;
                    }
                    // Restore custom reference
                    if (key.startsWith('custom_') && customIndicators.has(key)) {
                        value.custom = customIndicators.get(key);
                    }
                    indicators.set(key, value);
                });
                updateIndicatorTags();
            }
            
            // Load drawings
            loadDrawingsFromStorage();
            
            // Load alerts
            loadAlertsFromStorage();
            
            // Load chart type
            const savedChartType = localStorage.getItem('chartType');
            if (savedChartType) {
                chartType = savedChartType;
                document.getElementById('chartType').value = chartType;
            }
        }
        
        /* ================= NAVIGATION MENU ================= */
        function updateBotDisplay() {
            // Update bot display - placeholder function
            console.log('Bot display updated');
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const navMenuBtn = document.getElementById('navMenuBtn');
            const navMenu = document.getElementById('navMenu');
            
            navMenuBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                navMenu.classList.toggle('hidden');
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!navMenu.contains(e.target) && !navMenuBtn.contains(e.target)) {
                    navMenu.classList.add('hidden');
                }
            });
            
            // Close menu when pressing escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    navMenu.classList.add('hidden');
                }
            });
        });
        
        /* ================= CHART TYPES ================= */
        function setChartType(type) {
            chartType = type;
            localStorage.setItem('chartType', type);
            draw();
        }
        
        function drawChart(view, pad, candleSpacing, y1, window1H) {
            switch (chartType) {
                case 'line':
                    ctx.setLineDash([]);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#00c176';
                    ctx.beginPath();
                    let started = false;
                    view.forEach((c, i) => {
                        const x = pad + i * candleSpacing + candleSpacing / 2;
                        const y = y1(c.close);
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                    break;
                    
                case 'area':
                    ctx.setLineDash([]);
                    ctx.lineWidth = 2;
                    const gradient = ctx.createLinearGradient(0, pad, 0, pad + window1H);
                    gradient.addColorStop(0, 'rgba(0, 193, 118, 0.3)');
                    gradient.addColorStop(1, 'rgba(0, 193, 118, 0.05)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(pad, pad + window1H);
                    view.forEach((c, i) => {
                        const x = pad + i * candleSpacing + candleSpacing / 2;
                        ctx.lineTo(x, y1(c.close));
                    });
                    ctx.lineTo(pad + (view.length - 1) * candleSpacing + candleSpacing / 2, pad + window1H);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Line on top
                    ctx.strokeStyle = '#00c176';
                    ctx.beginPath();
                    view.forEach((c, i) => {
                        const x = pad + i * candleSpacing + candleSpacing / 2;
                        if (i === 0) ctx.moveTo(x, y1(c.close));
                        else ctx.lineTo(x, y1(c.close));
                    });
                    ctx.stroke();
                    break;
                    
                case 'bars':
                    ctx.setLineDash([]);
                    ctx.lineWidth = 1;
                    view.forEach((c, i) => {
                        const x = pad + i * candleSpacing + candleSpacing / 2;
                        const up = c.close >= c.open;
                        ctx.strokeStyle = up ? '#00c176' : '#ff4d4f';
                        
                        // High-Low line
                        ctx.beginPath();
                        ctx.moveTo(x, y1(c.high));
                        ctx.lineTo(x, y1(c.low));
                        ctx.stroke();
                        
                        // Open tick
                        ctx.beginPath();
                        ctx.moveTo(x - 3, y1(c.open));
                        ctx.lineTo(x, y1(c.open));
                        ctx.stroke();
                        
                        // Close tick
                        ctx.beginPath();
                        ctx.moveTo(x, y1(c.close));
                        ctx.lineTo(x + 3, y1(c.close));
                        ctx.stroke();
                    });
                    break;
                    
                default: // candles
                    view.forEach((c, i) => {
                        const x = pad + i * candleSpacing + candleSpacing / 2;
                        const up = c.close >= c.open;
                        
                        // Reset line dash and line width for candles
                        ctx.setLineDash([]);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = ctx.fillStyle = up ? '#00c176' : '#ff4d4f';

                        // Draw wick
                        ctx.beginPath();
                        ctx.moveTo(x, y1(c.high));
                        ctx.lineTo(x, y1(c.low));
                        ctx.stroke();

                        // Draw body with minimum width for visibility
                        const bodyWidth = Math.max(2, candleSpacing * 0.6);
                        const bodyHeight = Math.max(1, Math.abs(y1(c.close) - y1(c.open)));
                        
                        ctx.fillRect(
                            x - bodyWidth / 2,
                            Math.min(y1(c.open), y1(c.close)),
                            bodyWidth,
                            bodyHeight
                        );
                    });
            }
        }
        
        /* ================= PRICE ALERTS ================= */
        function toggleAlerts() {
            const panel = document.getElementById('alertPanel');
            showAlerts = !showAlerts;
            panel.style.display = showAlerts ? 'block' : 'none';
        }
        
        function closeAlerts() {
            document.getElementById('alertPanel').style.display = 'none';
            showAlerts = false;
        }
        
        function addAlert() {
            const price = parseFloat(document.getElementById('alertPrice').value);
            const type = document.getElementById('alertType').value;
            
            if (!price || isNaN(price)) {
                alert('Please enter a valid price');
                return;
            }
            
            const alert = {
                id: Date.now(),
                price: price,
                type: type,
                symbol: SYMBOL,
                triggered: false,
                created: new Date().toLocaleString()
            };
            
            priceAlerts.push(alert);
            updateAlertsList();
            saveAlertsToStorage();
            
            document.getElementById('alertPrice').value = '';
        }
        
        function removeAlert(id) {
            priceAlerts = priceAlerts.filter(a => a.id !== id);
            updateAlertsList();
            saveAlertsToStorage();
        }
        
        function updateAlertsList() {
            const list = document.getElementById('alertsList');
            list.innerHTML = priceAlerts.map(alert => `
                <div class="alert-item ${alert.triggered ? 'alert-triggered' : ''}">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span>${alert.symbol} ${alert.type} ${alert.price}</span>
                        <button onclick="removeAlert(${alert.id})" style="background: none; border: none; color: #ff4444; cursor: pointer;">&times;</button>
                    </div>
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">${alert.created}</div>
                </div>
            `).join('');
        }
        
        function checkAlerts(currentPrice) {
            priceAlerts.forEach(alert => {
                if (!alert.triggered && alert.symbol === SYMBOL) {
                    const shouldTrigger = 
                        (alert.type === 'above' && currentPrice >= alert.price) ||
                        (alert.type === 'below' && currentPrice <= alert.price);
                    
                    if (shouldTrigger) {
                        alert.triggered = true;
                        showNotification(`Alert: ${SYMBOL} is ${alert.type} ${alert.price}`);
                        updateAlertsList();
                        saveAlertsToStorage();
                    }
                }
            });
        }
        
        function showNotification(message) {
            if (Notification.permission === 'granted') {
                new Notification('Algocdk Price Alert', { body: message });
            } else {
                alert(message);
            }
        }
        
        function saveAlertsToStorage() {
            localStorage.setItem('priceAlerts', JSON.stringify(priceAlerts));
        }
        
        function loadAlertsFromStorage() {
            const saved = localStorage.getItem('priceAlerts');
            if (saved) {
                priceAlerts = JSON.parse(saved);
                updateAlertsList();
            }
        }
        
        /* ================= SCREENSHOT ================= */
        function takeScreenshot() {
            const link = document.createElement('a');
            link.download = `${SYMBOL}_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }
        
        /* ================= DRAWING TOOLS ================= */
        function setDrawingTool(tool) {
            drawingTool = tool;
            selectedDrawing = null;
            
            if (tool === 'delete') {
                canvas.style.cursor = 'crosshair';
                showDeleteInstructions();
            } else {
                canvas.style.cursor = tool ? 'crosshair' : 'grab';
                hideDeleteInstructions();
            }
            document.getElementById('drawingTool').value = tool;
        }
        
        function showDeleteInstructions() {
            if (!document.getElementById('deleteInstructions')) {
                const instructions = document.createElement('div');
                instructions.id = 'deleteInstructions';
                instructions.style.cssText = `
                    position: fixed; top: 150px; left: 50%; transform: translateX(-50%);
                    background: #ff4444; color: white; padding: 8px 16px; border-radius: 4px;
                    font-size: 14px; z-index: 200;
                `;
                instructions.textContent = 'üóëÔ∏è Click on any drawing to delete it';
                document.body.appendChild(instructions);
            }
        }
        
        function hideDeleteInstructions() {
            const instructions = document.getElementById('deleteInstructions');
            if (instructions) instructions.remove();
        }
        
        function startDrawing(x, y) {
            if (!drawingTool || drawingTool === 'delete') return;
            
            if (drawingTool === 'text') {
                addTextLabel(x, y);
                return;
            }
            
            isDrawing = true;
            const candleIndex = getCandleIndexFromX(x);
            const price = getPriceFromY(y);
            const color = document.getElementById('drawingColor').value;
            const lineStyle = document.getElementById('lineStyle').value;
            const lineWidth = parseInt(document.getElementById('lineWidth').value);
            
            currentDrawing = {
                id: Date.now(),
                type: drawingTool,
                startX: x,
                startY: y,
                endX: x,
                endY: y,
                startIndex: candleIndex,
                startPrice: price,
                endIndex: candleIndex,
                endPrice: price,
                color: color,
                lineStyle: lineStyle,
                lineWidth: lineWidth
            };
        }
        
        function updateDrawing(x, y) {
            if (!currentDrawing) return;
            
            currentDrawing.endX = x;
            currentDrawing.endY = y;
            currentDrawing.endIndex = getCandleIndexFromX(x);
            currentDrawing.endPrice = getPriceFromY(y);
            
            draw();
        }
        
        function finishDrawing() {
            if (currentDrawing) {
                drawings.push({...currentDrawing});
                currentDrawing = null;
                isDrawing = false;
                saveDrawingsToStorage();
            }
        }
        
        function addTextLabel(x, y) {
            const text = prompt('Enter text:');
            if (!text) return;
            
            const candleIndex = getCandleIndexFromX(x);
            const price = getPriceFromY(y);
            const color = document.getElementById('drawingColor').value;
            
            const textDrawing = {
                id: Date.now(),
                type: 'text',
                startIndex: candleIndex,
                startPrice: price,
                text: text,
                color: color,
                fontSize: 14
            };
            
            drawings.push(textDrawing);
            saveDrawingsToStorage();
            draw();
        }
        
        function deleteDrawingAt(x, y) {
            const clickTolerance = window.innerWidth < 768 ? 25 : 12;
            
            for (let i = drawings.length - 1; i >= 0; i--) {
                const drawing = drawings[i];
                
                // Convert drawing coordinates to current screen position
                const startScreenX = getXFromCandleIndex(drawing.startIndex);
                const endScreenX = getXFromCandleIndex(drawing.endIndex);
                const startScreenY = getYFromPrice(drawing.startPrice);
                const endScreenY = getYFromPrice(drawing.endPrice);
                
                let isNear = false;
                
                switch (drawing.type) {
                    case 'line':
                    case 'arrow':
                        isNear = distanceToLine(x, y, startScreenX, startScreenY, endScreenX, endScreenY) < clickTolerance;
                        break;
                    case 'horizontal':
                        isNear = Math.abs(y - startScreenY) < clickTolerance;
                        break;
                    case 'vertical':
                        isNear = Math.abs(x - startScreenX) < clickTolerance;
                        break;
                    case 'text':
                    case 'triangle':
                    case 'circle':
                    case 'fibext':
                    case 'pitchfork':
                    case 'gann':
                    case 'ray':
                        const minX = Math.min(startScreenX, endScreenX);
                        const maxX = Math.max(startScreenX, endScreenX);
                        const minY = Math.min(startScreenY, endScreenY);
                        const maxY = Math.max(startScreenY, endScreenY);
                        isNear = x >= minX - clickTolerance && x <= maxX + clickTolerance && 
                                y >= minY - clickTolerance && y <= maxY + clickTolerance;
                        break;
                }
                
                if (isNear) {
                    drawings.splice(i, 1);
                    saveDrawingsToStorage();
                    draw();
                    showDeleteFeedback();
                    return;
                }
            }
            showNoObjectFeedback();
        }
        
        function showDeleteFeedback() {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: #00c851; color: white; padding: 8px 16px; border-radius: 4px;
                font-size: 14px; z-index: 300;
            `;
            feedback.textContent = '‚úì Object deleted';
            document.body.appendChild(feedback);
            setTimeout(() => feedback.remove(), 1000);
        }
        
        function showNoObjectFeedback() {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: #ff4444; color: white; padding: 8px 16px; border-radius: 4px;
                font-size: 14px; z-index: 300;
            `;
            feedback.textContent = '‚ö†Ô∏è No object found here';
            document.body.appendChild(feedback);
            setTimeout(() => feedback.remove(), 1000);
        }
        
        function distanceToLine(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
            const projection_x = x1 + t * dx;
            const projection_y = y1 + t * dy;
            
            return Math.sqrt((px - projection_x) * (px - projection_x) + (py - projection_y) * (py - projection_y));
        }
        
        function clearAllDrawings() {
            drawings = [];
            currentDrawing = null;
            selectedDrawing = null;
            saveDrawingsToStorage();
            draw();
        }
        
        function getCandleIndexFromX(x) {
            const pad = 70;
            const candleSpacing = 6 * zoom;
            const w = canvas.width - pad * 2;
            const visible = Math.floor(w / candleSpacing);
            
            let data = [...candles];
            if (currentCandle) data.push(currentCandle);
            
            const start = Math.max(0, data.length - visible - Math.floor(offset));
            const relativeIndex = Math.floor((x - pad) / candleSpacing);
            
            return start + relativeIndex;
        }
        
        function getPriceFromY(y) {
            let data = [...candles];
            if (currentCandle) data.push(currentCandle);
            if (!data.length) return 0;
            
            const pad = 70;
            const totalH = canvas.height - pad * 2;
            const hasWindow2 = Array.from(indicators.values()).some(ind => ind.params?.window === 2);
            const window1H = hasWindow2 ? totalH * 0.7 : totalH;
            
            const candleSpacing = 6 * zoom;
            const w = canvas.width - pad * 2;
            const visible = Math.floor(w / candleSpacing);
            const start = Math.max(0, data.length - visible - Math.floor(offset));
            const view = data.slice(start, start + visible);
            
            if (!view.length) return 0;
            
            const max1 = Math.max(...view.map(c => c.high));
            const min1 = Math.min(...view.map(c => c.low));
            const range1 = max1 - min1 || 1;
            
            return max1 - ((y - pad) / window1H) * range1;
        }
        
        function getXFromCandleIndex(index) {
            const pad = 70;
            const candleSpacing = 6 * zoom;
            const w = canvas.width - pad * 2;
            const visible = Math.floor(w / candleSpacing);
            
            let data = [...candles];
            if (currentCandle) data.push(currentCandle);
            
            const start = Math.max(0, data.length - visible - Math.floor(offset));
            const relativeIndex = index - start;
            
            return pad + relativeIndex * candleSpacing + candleSpacing / 2;
        }
        
        function getYFromPrice(price) {
            let data = [...candles];
            if (currentCandle) data.push(currentCandle);
            if (!data.length) return 0;
            
            const pad = 70;
            const totalH = canvas.height - pad * 2;
            const hasWindow2 = Array.from(indicators.values()).some(ind => ind.params?.window === 2);
            const window1H = hasWindow2 ? totalH * 0.7 : totalH;
            
            const candleSpacing = 6 * zoom;
            const w = canvas.width - pad * 2;
            const visible = Math.floor(w / candleSpacing);
            const start = Math.max(0, data.length - visible - Math.floor(offset));
            const view = data.slice(start, start + visible);
            
            if (!view.length) return pad;
            
            const max1 = Math.max(...view.map(c => c.high));
            const min1 = Math.min(...view.map(c => c.low));
            const range1 = max1 - min1 || 1;
            
            return pad + window1H - ((price - min1) / range1) * window1H;
        }
        
        function drawDrawings() {
            // Draw saved drawings
            drawings.forEach(drawing => {
                drawSingleDrawing(drawing);
            });
            
            // Draw current drawing being created
            if (currentDrawing) {
                drawSingleDrawing(currentDrawing);
            }
        }
        
        function drawSingleDrawing(drawing) {
            // Convert stored candle indices and prices to current screen coordinates
            let data = [...candles];
            if (currentCandle) data.push(currentCandle);
            if (!data.length) return;
            
            const pad = 70;
            const candleSpacing = 6 * zoom;
            const visible = Math.floor((canvas.width - pad * 2) / candleSpacing);
            const start = Math.max(0, data.length - visible - Math.floor(offset));
            
            // Calculate current screen positions from stored data positions
            const startScreenX = pad + (drawing.startIndex - start) * candleSpacing + candleSpacing / 2;
            const endScreenX = pad + (drawing.endIndex - start) * candleSpacing + candleSpacing / 2;
            const startScreenY = getYFromPrice(drawing.startPrice);
            const endScreenY = getYFromPrice(drawing.endPrice);
            
            // Skip drawing if it's outside visible area
            if (startScreenX < 0 && endScreenX < 0) return;
            if (startScreenX > canvas.width && endScreenX > canvas.width) return;
            
            ctx.strokeStyle = drawing.color;
            ctx.fillStyle = drawing.color;
            ctx.lineWidth = drawing.lineWidth || 2;
            
            // Set line style
            switch (drawing.lineStyle) {
                case 'dashed': ctx.setLineDash([10, 5]); break;
                case 'dotted': ctx.setLineDash([2, 3]); break;
                default: ctx.setLineDash([]);
            }
            
            switch (drawing.type) {
                case 'text':
                    ctx.font = `${drawing.fontSize || 14}px Arial`;
                    ctx.fillText(drawing.text, startScreenX, startScreenY);
                    break;
                    
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(startScreenX, startScreenY);
                    ctx.lineTo(endScreenX, endScreenY);
                    ctx.stroke();
                    break;
                    
                case 'ray':
                    const dx = endScreenX - startScreenX;
                    const dy = endScreenY - startScreenY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 0) {
                        const extendX = startScreenX + (dx / length) * canvas.width;
                        const extendY = startScreenY + (dy / length) * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(startScreenX, startScreenY);
                        ctx.lineTo(extendX, extendY);
                        ctx.stroke();
                    }
                    break;
                    
                case 'horizontal':
                    ctx.beginPath();
                    ctx.moveTo(0, startScreenY);
                    ctx.lineTo(canvas.width, startScreenY);
                    ctx.stroke();
                    ctx.fillText(drawing.startPrice.toFixed(4), 5, startScreenY - 5);
                    break;
                    
                case 'vertical':
                    ctx.beginPath();
                    ctx.moveTo(startScreenX, 0);
                    ctx.lineTo(startScreenX, canvas.height);
                    ctx.stroke();
                    break;
                    
                case 'rectangle':
                    const width = endScreenX - startScreenX;
                    const height = endScreenY - startScreenY;
                    ctx.strokeRect(startScreenX, startScreenY, width, height);
                    break;
                    
                case 'triangle':
                    const midX = (startScreenX + endScreenX) / 2;
                    ctx.beginPath();
                    ctx.moveTo(midX, startScreenY);
                    ctx.lineTo(startScreenX, endScreenY);
                    ctx.lineTo(endScreenX, endScreenY);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 'circle':
                    const radius = Math.abs(endScreenX - startScreenX) / 2;
                    const centerX = (startScreenX + endScreenX) / 2;
                    const centerY = (startScreenY + endScreenY) / 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                    break;
                    
                case 'fibonacci':
                    const fibLevels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
                    const fibHeight = endScreenY - startScreenY;
                    
                    fibLevels.forEach(level => {
                        const y = startScreenY + fibHeight * level;
                        ctx.globalAlpha = 0.7;
                        ctx.beginPath();
                        ctx.moveTo(Math.min(startScreenX, endScreenX), y);
                        ctx.lineTo(Math.max(startScreenX, endScreenX), y);
                        ctx.stroke();
                        ctx.fillText(`${(level * 100).toFixed(1)}%`, Math.min(startScreenX, endScreenX) + 5, y - 5);
                    });
                    ctx.globalAlpha = 1;
                    break;
                    
                case 'fibext':
                    const extLevels = [0, 0.618, 1, 1.272, 1.618, 2.618];
                    const extHeight = endScreenY - startScreenY;
                    
                    extLevels.forEach(level => {
                        const y = startScreenY + extHeight * level;
                        ctx.globalAlpha = 0.7;
                        ctx.beginPath();
                        ctx.moveTo(Math.min(startScreenX, endScreenX), y);
                        ctx.lineTo(Math.max(startScreenX, endScreenX), y);
                        ctx.stroke();
                        ctx.fillText(`${(level * 100).toFixed(1)}%`, Math.min(startScreenX, endScreenX) + 5, y - 5);
                    });
                    ctx.globalAlpha = 1;
                    break;
                    
                case 'channel':
                    ctx.beginPath();
                    ctx.moveTo(startScreenX, startScreenY);
                    ctx.lineTo(endScreenX, endScreenY);
                    ctx.stroke();
                    
                    const priceDiff = Math.abs(drawing.endPrice - drawing.startPrice) * 0.5;
                    const offsetY = drawing.startPrice > drawing.endPrice ? -priceDiff : priceDiff;
                    const offsetStartY = getYFromPrice(drawing.startPrice + offsetY);
                    const offsetEndY = getYFromPrice(drawing.endPrice + offsetY);
                    
                    ctx.beginPath();
                    ctx.moveTo(startScreenX, offsetStartY);
                    ctx.lineTo(endScreenX, offsetEndY);
                    ctx.stroke();
                    break;
                    
                case 'pitchfork':
                    ctx.beginPath();
                    ctx.moveTo(startScreenX, startScreenY);
                    ctx.lineTo(endScreenX, endScreenY);
                    ctx.stroke();
                    
                    const pitchDiff = (endScreenY - startScreenY) * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(startScreenX, startScreenY - pitchDiff);
                    ctx.lineTo(endScreenX, endScreenY - pitchDiff);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(startScreenX, startScreenY + pitchDiff);
                    ctx.lineTo(endScreenX, endScreenY + pitchDiff);
                    ctx.stroke();
                    break;
                    
                case 'gann':
                    const angles = [15, 30, 45, 60, 75];
                    const gannLength = 200;
                    
                    angles.forEach(angle => {
                        const radians = (angle * Math.PI) / 180;
                        const gannEndX = startScreenX + gannLength * Math.cos(radians);
                        const gannEndY = startScreenY - gannLength * Math.sin(radians);
                        
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(startScreenX, startScreenY);
                        ctx.lineTo(gannEndX, gannEndY);
                        ctx.stroke();
                        
                        const mirrorEndX = startScreenX + gannLength * Math.cos(-radians);
                        const mirrorEndY = startScreenY - gannLength * Math.sin(-radians);
                        ctx.beginPath();
                        ctx.moveTo(startScreenX, startScreenY);
                        ctx.lineTo(mirrorEndX, mirrorEndY);
                        ctx.stroke();
                    });
                    ctx.globalAlpha = 1;
                    break;
                    
                case 'arrow':
                    ctx.beginPath();
                    ctx.moveTo(startScreenX, startScreenY);
                    ctx.lineTo(endScreenX, endScreenY);
                    ctx.stroke();
                    
                    const angle = Math.atan2(endScreenY - startScreenY, endScreenX - startScreenX);
                    const headLength = 15;
                    
                    ctx.beginPath();
                    ctx.moveTo(endScreenX, endScreenY);
                    ctx.lineTo(
                        endScreenX - headLength * Math.cos(angle - Math.PI / 6),
                        endScreenY - headLength * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.moveTo(endScreenX, endScreenY);
                    ctx.lineTo(
                        endScreenX - headLength * Math.cos(angle + Math.PI / 6),
                        endScreenY - headLength * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.stroke();
                    break;
            }
        }
        
        function saveDrawingsToStorage() {
            localStorage.setItem('chartDrawings', JSON.stringify(drawings));
        }
        
        function loadDrawingsFromStorage() {
            const saved = localStorage.getItem('chartDrawings');
            if (saved) {
                drawings = JSON.parse(saved);
            }
        }
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (drawingTool === 'delete') {
                deleteDrawingAt(x, y);
            } else if (drawingTool) {
                startDrawing(x, y);
            } else {
                isDragging = true;
                lastX = touch.clientX;
            }
        });
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                updateDrawing(x, y);
            } else if (isDragging && !drawingTool) {
                offset += (touch.clientX - lastX) / 10;
                lastX = touch.clientX;
                draw();
            }
        });
        
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            if (isDrawing) {
                finishDrawing();
            }
            isDragging = false;
        });
        
        window.addEventListener('resize', () => {
            resize();
        });
        
        /* ================= FULLSCREEN ================= */
        function toggleFullscreen() {
            const chartContainer = document.querySelector('.flex-1.relative');
            const btn = document.getElementById('fullscreenBtn');
            
            if (!document.fullscreenElement) {
                chartContainer.requestFullscreen().then(() => {
                    btn.innerHTML = '<i class="fas fa-compress"></i>';
                    btn.title = 'Exit Fullscreen';
                    setTimeout(() => resize(), 100);
                }).catch(err => {
                    console.error('Error entering fullscreen:', err);
                });
            } else {
                document.exitFullscreen().then(() => {
                    btn.innerHTML = '<i class="fas fa-expand"></i>';
                    btn.title = 'Toggle Fullscreen';
                    setTimeout(() => resize(), 100);
                }).catch(err => {
                    console.error('Error exiting fullscreen:', err);
                });
            }
        }
        
        // Listen for fullscreen changes (e.g., ESC key)
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('fullscreenBtn');
            if (!document.fullscreenElement) {
                btn.innerHTML = '<i class="fas fa-expand"></i>';
                btn.title = 'Toggle Fullscreen';
                setTimeout(() => resize(), 100);
            }
        });
        
        /* ================= EXIT APP ================= */
        function exitApp() {
            // Clear all tokens and session data
            localStorage.removeItem('authToken');
            localStorage.removeItem('jwt_token');
            localStorage.removeItem('token');
            localStorage.removeItem('userRole');
            localStorage.removeItem('userId');
            localStorage.removeItem('adminId');
            localStorage.removeItem('superadminId');
            localStorage.removeItem('preferredAccountType');
            localStorage.removeItem('demoBalance');
            localStorage.removeItem('realBalance');
            
            // Close WebSocket connections
            if (ws) {
                ws.close();
                ws = null;
            }
            if (derivWS) {
                derivWS.close();
                derivWS = null;
            }
            if (backgroundWs) {
                backgroundWs.close();
                backgroundWs = null;
            }
            
            // Reset all global variables
            authToken = null;
            isRealAccount = false;
            demoBalance = 10000;
            realBalance = 1000;
            candles = [];
            currentCandle = null;
            
            // Clear session storage
            sessionStorage.clear();
            
            // Redirect to home/login
            window.location.href = '/';
        }
        
        /* ================= START ================= */
        async function initializeApp() {
            initMarketData();
            loadIndicatorsFromStorage();
            connect();
            updateBotDisplay();
            startBackgroundUpdates();
            await initializeAccountDisplay(); // Initialize account display with proper token handling
            initProfessionalFeatures(); // Initialize professional features
            
            // Request notification permission
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }
        
        initializeApp();
    </script>

</body>

</html>